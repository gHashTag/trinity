// Trinity Codegen Adapter
// Generated from: specs/tri/plugin/adapters/codegen_adapter.vibee
// Sacred Formula: V = n x 3^k x pi^m x phi^p x e^q
// Golden Identity: phi^2 + 1/phi^2 = 3
//
// Purpose: Wrap multi_lang_codegen generators as unified Plugin interface.
// Supports all 42 programming languages via single Plugin interface.

const std = @import("std");
const Allocator = std.mem.Allocator;

// Import via build.zig module or relative path fallback
const plugin_interface = @import("plugin_interface");
const Plugin = plugin_interface.Plugin;
const PluginMetadata = plugin_interface.PluginMetadata;
const PluginKind = plugin_interface.PluginKind;
const PluginCapability = plugin_interface.PluginCapability;
const PluginResult = plugin_interface.PluginResult;
const PluginVTable = plugin_interface.PluginVTable;

const multi_lang_codegen = @import("multi_lang_codegen");
const Language = multi_lang_codegen.Language;

// ============================================================================
// CONSTANTS
// ============================================================================

pub const CODEGEN_CAPABILITY = "generate";
pub const CODEGEN_NAMESPACE = "trinity.codegen";
pub const MAX_OUTPUT_SIZE: usize = 10 * 1024 * 1024; // 10MB

// ============================================================================
// ADAPTER CONTEXT
// ============================================================================

/// Context holding codegen state
pub const CodegenPluginContext = struct {
    language: Language,
    allocator: Allocator,
    output_buffer: std.ArrayList(u8),
    last_spec_path: ?[]const u8,

    const Self = @This();

    pub fn init(allocator: Allocator, language: Language) Self {
        return .{
            .language = language,
            .allocator = allocator,
            .output_buffer = .{},
            .last_spec_path = null,
        };
    }

    pub fn deinit(self: *Self) void {
        self.output_buffer.deinit(self.allocator);
        self.last_spec_path = null;
    }

    pub fn clearBuffer(self: *Self) void {
        self.output_buffer.clearRetainingCapacity();
    }
};

/// Single language codegen as Plugin
pub const CodegenPlugin = struct {
    plugin: Plugin,
    context: CodegenPluginContext,

    const Self = @This();

    pub fn getPlugin(self: *Self) *Plugin {
        return &self.plugin;
    }
};

// ============================================================================
// VTABLE IMPLEMENTATION
// ============================================================================

const codegen_vtable = PluginVTable{
    .init_fn = codegenInit,
    .deinit_fn = codegenDeinit,
    .invoke_fn = codegenInvoke,
    .capabilities_fn = codegenCapabilities,
};

fn codegenInit(ctx: *anyopaque, _: Allocator, _: []const u8) anyerror!void {
    const context: *CodegenPluginContext = @ptrCast(@alignCast(ctx));
    context.clearBuffer();
}

fn codegenDeinit(ctx: *anyopaque) void {
    const context: *CodegenPluginContext = @ptrCast(@alignCast(ctx));
    context.deinit();
}

fn codegenInvoke(ctx: *anyopaque, operation: []const u8, input: []const u8) anyerror!PluginResult {
    const context: *CodegenPluginContext = @ptrCast(@alignCast(ctx));

    // Only "generate" operation is supported
    if (!std.mem.eql(u8, operation, CODEGEN_CAPABILITY)) {
        return PluginResult.err(&[_][]const u8{"Unknown operation. Use 'generate'."}, 0);
    }

    // Clear previous output
    context.clearBuffer();
    context.last_spec_path = input;

    const timer_start = std.time.nanoTimestamp();

    // Generate code header based on language
    const lang_name = context.language.name();
    const extension = context.language.extension();

    // Generate stub code (actual codegen would parse spec and generate)
    try context.output_buffer.appendSlice(context.allocator,"// Generated by Trinity Codegen\n");
    try context.output_buffer.appendSlice(context.allocator,"// Language: ");
    try context.output_buffer.appendSlice(context.allocator,lang_name);
    try context.output_buffer.appendSlice(context.allocator,"\n");
    try context.output_buffer.appendSlice(context.allocator,"// Extension: ");
    try context.output_buffer.appendSlice(context.allocator,extension);
    try context.output_buffer.appendSlice(context.allocator,"\n");
    try context.output_buffer.appendSlice(context.allocator,"// Spec: ");
    try context.output_buffer.appendSlice(context.allocator,input);
    try context.output_buffer.appendSlice(context.allocator,"\n\n");

    // Add language-specific stub
    try generateLanguageStub(context);

    const duration: i64 = @intCast(std.time.nanoTimestamp() - timer_start);

    return PluginResult{
        .success = true,
        .output = context.output_buffer.items,
        .errors = &[_][]const u8{},
        .duration_ns = duration,
        .memory_bytes = context.output_buffer.items.len,
    };
}

fn codegenCapabilities(_: *anyopaque) []const PluginCapability {
    return &[_]PluginCapability{
        .{ .name = CODEGEN_CAPABILITY, .version = "1.0.0" },
    };
}

// ============================================================================
// LANGUAGE-SPECIFIC STUBS
// ============================================================================

fn generateLanguageStub(context: *CodegenPluginContext) !void {
    switch (context.language) {
        .zig => {
            try context.output_buffer.appendSlice(context.allocator,"const std = @import(\"std\");\n\n");
            try context.output_buffer.appendSlice(context.allocator,"pub fn main() void {\n");
            try context.output_buffer.appendSlice(context.allocator,"    // TODO: Generated code\n");
            try context.output_buffer.appendSlice(context.allocator,"}\n");
        },
        .rust => {
            try context.output_buffer.appendSlice(context.allocator,"fn main() {\n");
            try context.output_buffer.appendSlice(context.allocator,"    // TODO: Generated code\n");
            try context.output_buffer.appendSlice(context.allocator,"}\n");
        },
        .python => {
            try context.output_buffer.appendSlice(context.allocator,"#!/usr/bin/env python3\n\n");
            try context.output_buffer.appendSlice(context.allocator,"def main():\n");
            try context.output_buffer.appendSlice(context.allocator,"    # TODO: Generated code\n");
            try context.output_buffer.appendSlice(context.allocator,"    pass\n\n");
            try context.output_buffer.appendSlice(context.allocator,"if __name__ == '__main__':\n");
            try context.output_buffer.appendSlice(context.allocator,"    main()\n");
        },
        .go => {
            try context.output_buffer.appendSlice(context.allocator,"package main\n\n");
            try context.output_buffer.appendSlice(context.allocator,"func main() {\n");
            try context.output_buffer.appendSlice(context.allocator,"    // TODO: Generated code\n");
            try context.output_buffer.appendSlice(context.allocator,"}\n");
        },
        .java => {
            try context.output_buffer.appendSlice(context.allocator,"public class Generated {\n");
            try context.output_buffer.appendSlice(context.allocator,"    public static void main(String[] args) {\n");
            try context.output_buffer.appendSlice(context.allocator,"        // TODO: Generated code\n");
            try context.output_buffer.appendSlice(context.allocator,"    }\n");
            try context.output_buffer.appendSlice(context.allocator,"}\n");
        },
        else => {
            try context.output_buffer.appendSlice(context.allocator,"// TODO: Generated code for ");
            try context.output_buffer.appendSlice(context.allocator,context.language.name());
            try context.output_buffer.appendSlice(context.allocator,"\n");
        },
    }
}

// ============================================================================
// PUBLIC API
// ============================================================================

/// Create a codegen plugin for a specific language
pub fn wrapCodegen(allocator: Allocator, language: Language) !*CodegenPlugin {
    const codegen = try allocator.create(CodegenPlugin);

    // Initialize context
    codegen.context = CodegenPluginContext.init(allocator, language);

    // Build plugin ID: trinity.codegen.<language>
    const lang_str = language.name();
    const id = try std.fmt.allocPrint(allocator, "{s}.{s}", .{ CODEGEN_NAMESPACE, lang_str });

    // Create Plugin with metadata
    codegen.plugin = Plugin{
        .metadata = PluginMetadata{
            .id = id,
            .name = lang_str,
            .version = "1.0.0",
            .author = "Trinity Team",
            .kind = .codegen,
            .capabilities = &[_]PluginCapability{
                .{ .name = CODEGEN_CAPABILITY, .version = "1.0.0" },
            },
            .dependencies = &[_][]const u8{},
            .trinity_version = ">=22.0.0",
        },
        .state = .{ .loaded = true, .enabled = true },
        .vtable = &codegen_vtable,
        .context = &codegen.context,
    };

    return codegen;
}

/// Get list of all supported languages
pub fn getSupportedLanguages() []const Language {
    return &[_]Language{
        .zig,
        .rust,
        .python,
        .go,
        .java,
        .kotlin,
        .swift,
        .c,
        .haskell,
        .ocaml,
        .julia,
        .ruby,
        .php,
        .lua,
        .perl,
        .d_lang,
        .nim,
        .crystal,
        .scala,
        .fsharp,
        .clojure,
        .erlang,
        .elixir,
        .fortran,
        .ada,
        .cobol,
        .pascal,
        .r_lang,
        .dart,
        .v_lang,
        .odin,
        .jai,
        .scheme,
        .racket,
        .common_lisp,
        .prolog,
        .objc,
        .groovy,
        .wasm,
        .gleam,
    };
}

/// Create plugins for all supported languages
pub fn createAllCodegenPlugins(allocator: Allocator) ![]const *CodegenPlugin {
    const languages = getSupportedLanguages();
    var plugins = std.ArrayList(*CodegenPlugin).init(allocator);
    errdefer plugins.deinit();

    for (languages) |lang| {
        const plugin = try wrapCodegen(allocator, lang);
        try plugins.append(plugin);
    }

    return plugins.toOwnedSlice();
}

/// Free all codegen plugins
pub fn freeAllCodegenPlugins(allocator: Allocator, plugins: []const *CodegenPlugin) void {
    for (plugins) |plugin| {
        plugin.context.deinit();
        allocator.free(plugin.plugin.metadata.id);
        allocator.destroy(plugin);
    }
    allocator.free(plugins);
}

/// Check if a Plugin is a codegen plugin
pub fn isCodegenPlugin(plugin: *const Plugin) bool {
    return plugin.metadata.kind == .codegen and
        plugin.vtable == &codegen_vtable;
}

/// Detect language from spec file extension or language field
pub fn detectLanguageFromSpec(spec_path: []const u8) ?Language {
    // Check extension
    if (std.mem.endsWith(u8, spec_path, ".py")) return .python;
    if (std.mem.endsWith(u8, spec_path, ".rs")) return .rust;
    if (std.mem.endsWith(u8, spec_path, ".go")) return .go;
    if (std.mem.endsWith(u8, spec_path, ".zig")) return .zig;
    if (std.mem.endsWith(u8, spec_path, ".java")) return .java;

    // Default to Zig
    return .zig;
}

// ============================================================================
// TESTS
// ============================================================================

test "wrap codegen plugin zig" {
    const allocator = std.testing.allocator;

    const codegen = try wrapCodegen(allocator, .zig);
    defer {
        codegen.context.deinit();
        allocator.free(codegen.plugin.metadata.id);
        allocator.destroy(codegen);
    }

    // Verify metadata
    try std.testing.expectEqualStrings("Zig", codegen.plugin.metadata.name);
    try std.testing.expect(codegen.plugin.metadata.kind == .codegen);

    // Verify ID format
    try std.testing.expect(std.mem.startsWith(u8, codegen.plugin.metadata.id, CODEGEN_NAMESPACE));
}

test "codegen plugin has generate capability" {
    const allocator = std.testing.allocator;

    const codegen = try wrapCodegen(allocator, .python);
    defer {
        codegen.context.deinit();
        allocator.free(codegen.plugin.metadata.id);
        allocator.destroy(codegen);
    }

    try std.testing.expect(codegen.plugin.hasCapability(CODEGEN_CAPABILITY));
}

test "is codegen plugin check" {
    const allocator = std.testing.allocator;

    const codegen = try wrapCodegen(allocator, .rust);
    defer {
        codegen.context.deinit();
        allocator.free(codegen.plugin.metadata.id);
        allocator.destroy(codegen);
    }

    try std.testing.expect(isCodegenPlugin(&codegen.plugin));
}

test "get supported languages" {
    const languages = getSupportedLanguages();
    try std.testing.expect(languages.len > 30); // At least 30 languages
}

test "detect language from spec path" {
    try std.testing.expect(detectLanguageFromSpec("test.py") == .python);
    try std.testing.expect(detectLanguageFromSpec("test.rs") == .rust);
    try std.testing.expect(detectLanguageFromSpec("test.zig") == .zig);
    try std.testing.expect(detectLanguageFromSpec("test.go") == .go);
}

test "invoke generate operation" {
    const allocator = std.testing.allocator;

    const codegen = try wrapCodegen(allocator, .zig);
    defer {
        codegen.context.deinit();
        allocator.free(codegen.plugin.metadata.id);
        allocator.destroy(codegen);
    }

    // Invoke generate
    const result = try codegen.plugin.invoke(CODEGEN_CAPABILITY, "specs/tri/test.vibee");

    try std.testing.expect(result.success);
    try std.testing.expect(result.output != null);
    try std.testing.expect(std.mem.indexOf(u8, result.output.?, "Zig") != null);
}
