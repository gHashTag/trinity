"use strict";(globalThis.webpackChunkdocsite=globalThis.webpackChunkdocsite||[]).push([[1743],{3333(e,i,n){n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"concepts/glossary","title":"Glossary","description":"Quick reference for terms used throughout Trinity documentation. If a term is missing, check the API Reference for module-specific definitions.","source":"@site/docs/concepts/glossary.md","sourceDirName":"concepts","slug":"/concepts/glossary","permalink":"/trinity/docs/concepts/glossary","draft":false,"unlisted":false,"editUrl":"https://github.com/gHashTag/trinity/tree/main/docsite/docs/concepts/glossary.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"The Trinity Identity","permalink":"/trinity/docs/concepts/trinity-identity"},"next":{"title":"BitNet Integration","permalink":"/trinity/docs/bitnet/"}}');var t=n(4848),s=n(8453);const o={sidebar_position:4},a="Glossary",d={},c=[{value:"Balanced ternary",id:"balanced-ternary",level:3},{value:"Bind",id:"bind",level:3},{value:"BitNet b1.58",id:"bitnet-b158",level:3},{value:"Bundle",id:"bundle",level:3},{value:"Codebook",id:"codebook",level:3},{value:"Cosine similarity",id:"cosine-similarity",level:3},{value:"Dense vector",id:"dense-vector",level:3},{value:"Dimension",id:"dimension",level:3},{value:"Dot product",id:"dot-product",level:3},{value:"Hamming distance",id:"hamming-distance",level:3},{value:"HDC",id:"hdc",level:3},{value:"HybridBigInt",id:"hybridbigint",level:3},{value:"Hypervector",id:"hypervector",level:3},{value:"JIT",id:"jit",level:3},{value:"Majority vote",id:"majority-vote",level:3},{value:"N-gram",id:"n-gram",level:3},{value:"Packed mode",id:"packed-mode",level:3},{value:"Permute",id:"permute",level:3},{value:"Quasi-orthogonal",id:"quasi-orthogonal",level:3},{value:"Sparse vector",id:"sparse-vector",level:3},{value:"Trit",id:"trit",level:3},{value:"Unbind",id:"unbind",level:3},{value:"Unpacked mode",id:"unpacked-mode",level:3},{value:"VSA",id:"vsa",level:3}];function l(e){const i={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",hr:"hr",p:"p",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"glossary",children:"Glossary"})}),"\n",(0,t.jsxs)(i.p,{children:["Quick reference for terms used throughout Trinity documentation. If a term is missing, check the ",(0,t.jsx)(i.a,{href:"/docs/api/",children:"API Reference"})," for module-specific definitions."]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h3,{id:"balanced-ternary",children:"Balanced ternary"}),"\n",(0,t.jsxs)(i.p,{children:["Number system using {-1, 0, +1} instead of {0, 1, 2}. Negation is a simple sign flip. Truncation rounds to the nearest value automatically. See ",(0,t.jsx)(i.a,{href:"/docs/concepts/",children:"Ternary Computing Concepts"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"bind",children:"Bind"}),"\n",(0,t.jsxs)(i.p,{children:["VSA operation that links two vectors via element-wise multiplication. The result is dissimilar to both inputs. Binding is its own inverse: ",(0,t.jsx)(i.code,{children:"bind(bind(a, b), b) = a"}),". See ",(0,t.jsx)(i.a,{href:"/docs/api/vsa",children:"VSA API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"bitnet-b158",children:"BitNet b1.58"}),"\n",(0,t.jsxs)(i.p,{children:["Neural network architecture using ternary weights {-1, 0, +1}. Each weight uses approximately 1.58 bits of storage. Eliminates multiplication in matrix operations. See ",(0,t.jsx)(i.a,{href:"/docs/bitnet",children:"BitNet"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"bundle",children:"Bundle"}),"\n",(0,t.jsxs)(i.p,{children:["VSA operation that combines vectors via majority vote. The result is similar to all inputs. Used to store multiple items in a single vector. See ",(0,t.jsx)(i.a,{href:"/docs/api/vsa",children:"VSA API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"codebook",children:"Codebook"}),"\n",(0,t.jsxs)(i.p,{children:["A mapping from symbols (characters, words, labels) to ",(0,t.jsx)(i.a,{href:"#hypervector",children:"hypervectors"}),". Also called ItemMemory. Each symbol gets a unique random vector. See ",(0,t.jsx)(i.a,{href:"/docs/api/sequence-hdc",children:"Sequence HDC"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"cosine-similarity",children:"Cosine similarity"}),"\n",(0,t.jsx)(i.p,{children:"Measure of the angle between two vectors. Range: [-1, 1]. A value of +1 means identical, 0 means unrelated, and -1 means opposite. The primary similarity metric in Trinity's VSA."}),"\n",(0,t.jsx)(i.h3,{id:"dense-vector",children:"Dense vector"}),"\n",(0,t.jsxs)(i.p,{children:["Vector that stores all elements explicitly, including zeros. Contrast with ",(0,t.jsx)(i.a,{href:"#sparse-vector",children:"sparse vector"}),". See ",(0,t.jsx)(i.a,{href:"/docs/api/hybrid",children:"HybridBigInt"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"dimension",children:"Dimension"}),"\n",(0,t.jsxs)(i.p,{children:["The number of elements (",(0,t.jsx)(i.a,{href:"#trit",children:"trits"}),") in a vector. Typical range: 1000 to 10000. Higher dimensions give better noise tolerance and cleaner separation between unrelated vectors."]}),"\n",(0,t.jsx)(i.h3,{id:"dot-product",children:"Dot product"}),"\n",(0,t.jsxs)(i.p,{children:["Sum of element-wise products of two vectors. Related to ",(0,t.jsx)(i.a,{href:"#cosine-similarity",children:"cosine similarity"})," but without normalization by vector magnitudes."]}),"\n",(0,t.jsx)(i.h3,{id:"hamming-distance",children:"Hamming distance"}),"\n",(0,t.jsxs)(i.p,{children:["Count of positions where two vectors differ. A distance of zero means the vectors are identical. Maximum distance equals the ",(0,t.jsx)(i.a,{href:"#dimension",children:"dimension"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"hdc",children:"HDC"}),"\n",(0,t.jsxs)(i.p,{children:["Hyperdimensional Computing. A computing framework that uses high-dimensional vectors for representation and reasoning. Equivalent to ",(0,t.jsx)(i.a,{href:"#vsa",children:"VSA"}),". The two terms are used interchangeably."]}),"\n",(0,t.jsx)(i.h3,{id:"hybridbigint",children:"HybridBigInt"}),"\n",(0,t.jsxs)(i.p,{children:["Trinity's main vector type. Supports dual-mode storage: ",(0,t.jsx)(i.a,{href:"#packed-mode",children:"packed mode"})," for memory efficiency and ",(0,t.jsx)(i.a,{href:"#unpacked-mode",children:"unpacked mode"})," for fast computation. Switches between modes automatically. See ",(0,t.jsx)(i.a,{href:"/docs/api/hybrid",children:"Hybrid API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"hypervector",children:"Hypervector"}),"\n",(0,t.jsxs)(i.p,{children:["A vector with thousands of dimensions, typically 1000 to 10000 ",(0,t.jsx)(i.a,{href:"#trit",children:"trits"}),". The high dimensionality ensures that random vectors are ",(0,t.jsx)(i.a,{href:"#quasi-orthogonal",children:"quasi-orthogonal"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"jit",children:"JIT"}),"\n",(0,t.jsxs)(i.p,{children:["Just-In-Time compilation. Trinity's JIT engine generates native SIMD instructions at runtime for faster VSA operations. See ",(0,t.jsx)(i.a,{href:"/docs/api/jit",children:"JIT API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"majority-vote",children:"Majority vote"}),"\n",(0,t.jsxs)(i.p,{children:["Decision rule used in ",(0,t.jsx)(i.a,{href:"#bundle",children:"bundling"}),". For each position, take the most common value among the input vectors. Ties are broken randomly. This preserves the signal from each input."]}),"\n",(0,t.jsx)(i.h3,{id:"n-gram",children:"N-gram"}),"\n",(0,t.jsxs)(i.p,{children:['A contiguous subsequence of N items. For text, these are usually characters. The word "hello" contains the trigrams (3-grams): "hel", "ell", "llo". Used in ',(0,t.jsx)(i.a,{href:"/docs/api/sequence-hdc",children:"Sequence HDC"})," for text encoding."]}),"\n",(0,t.jsx)(i.h3,{id:"packed-mode",children:"Packed mode"}),"\n",(0,t.jsxs)(i.p,{children:["Storage mode using approximately 1.58 bits per ",(0,t.jsx)(i.a,{href:"#trit",children:"trit"}),". Highly memory-efficient. Element access requires bit manipulation, making it slower than ",(0,t.jsx)(i.a,{href:"#unpacked-mode",children:"unpacked mode"}),". Ideal for storage and transfer. See ",(0,t.jsx)(i.a,{href:"/docs/api/hybrid",children:"Hybrid API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"permute",children:"Permute"}),"\n",(0,t.jsxs)(i.p,{children:["Cyclic shift of vector elements. Shifts all elements by a given count, wrapping around at the boundary. The result is dissimilar to the original vector. Used to encode position or sequence order. See ",(0,t.jsx)(i.a,{href:"/docs/api/vsa",children:"VSA API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"quasi-orthogonal",children:"Quasi-orthogonal"}),"\n",(0,t.jsxs)(i.p,{children:["Two vectors with ",(0,t.jsx)(i.a,{href:"#cosine-similarity",children:"cosine similarity"})," near zero. In high-dimensional spaces, random vectors are almost always quasi-orthogonal. This is the mathematical foundation that allows random vectors to represent distinct concepts."]}),"\n",(0,t.jsx)(i.h3,{id:"sparse-vector",children:"Sparse vector"}),"\n",(0,t.jsxs)(i.p,{children:["Vector that stores only non-zero elements using coordinate (COO) format. Efficient when most elements are zero. Uses less memory than ",(0,t.jsx)(i.a,{href:"#dense-vector",children:"dense vectors"})," for high-sparsity data. See ",(0,t.jsx)(i.a,{href:"/docs/api/sparse",children:"Sparse API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"trit",children:"Trit"}),"\n",(0,t.jsx)(i.p,{children:"A ternary digit. Takes the value -1, 0, or +1. Carries log2(3) = 1.58 bits of information. The fundamental unit of data in Trinity."}),"\n",(0,t.jsx)(i.h3,{id:"unbind",children:"Unbind"}),"\n",(0,t.jsxs)(i.p,{children:["Reverse of ",(0,t.jsx)(i.a,{href:"#bind",children:"bind"}),". Recovers one vector from a binding given the other. Because binding uses element-wise multiplication and trits are self-inverse, unbinding is mathematically identical to binding. See ",(0,t.jsx)(i.a,{href:"/docs/api/vsa",children:"VSA API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"unpacked-mode",children:"Unpacked mode"}),"\n",(0,t.jsxs)(i.p,{children:["Storage mode using 8 bits (one byte) per ",(0,t.jsx)(i.a,{href:"#trit",children:"trit"}),". Allows fast element access with no bit manipulation. Uses 5x more memory than ",(0,t.jsx)(i.a,{href:"#packed-mode",children:"packed mode"}),". Ideal for computation. See ",(0,t.jsx)(i.a,{href:"/docs/api/hybrid",children:"Hybrid API"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"vsa",children:"VSA"}),"\n",(0,t.jsxs)(i.p,{children:["Vector Symbolic Architecture. A framework for symbolic AI that uses high-dimensional vectors. Core operations are ",(0,t.jsx)(i.a,{href:"#bind",children:"bind"}),", ",(0,t.jsx)(i.a,{href:"#bundle",children:"bundle"}),", and ",(0,t.jsx)(i.a,{href:"#permute",children:"permute"}),". Trinity implements VSA using balanced ternary vectors. See ",(0,t.jsx)(i.a,{href:"/docs/api/vsa",children:"VSA API"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453(e,i,n){n.d(i,{R:()=>o,x:()=>a});var r=n(6540);const t={},s=r.createContext(t);function o(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);