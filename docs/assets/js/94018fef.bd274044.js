"use strict";(globalThis.webpackChunkdocsite=globalThis.webpackChunkdocsite||[]).push([[8870],{3935(e,t,r){r.r(t),r.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>l,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"benchmarks/memory-efficiency","title":"Memory Efficiency","description":"Trinity achieves up to 20x memory savings compared to float32 representations through a combination of packed ternary encoding, lazy conversion strategies, and sparse vector formats. This page explains each memory optimization technique and when to use it.","source":"@site/docs/benchmarks/memory-efficiency.md","sourceDirName":"benchmarks","slug":"/benchmarks/memory-efficiency","permalink":"/trinity/docs/benchmarks/memory-efficiency","draft":false,"unlisted":false,"editUrl":"https://github.com/gHashTag/trinity/tree/main/docsite/docs/benchmarks/memory-efficiency.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"JIT Compilation Performance","permalink":"/trinity/docs/benchmarks/jit-performance"},"next":{"title":"Competitor Comparison","permalink":"/trinity/docs/benchmarks/competitor-comparison"}}');var i=r(4848),s=r(8453);const o={sidebar_position:4},d="Memory Efficiency",a={},c=[{value:"Ternary Information Density",id:"ternary-information-density",level:2},{value:"HybridBigInt: Dual Representation",id:"hybridbigint-dual-representation",level:2},{value:"Packed Trit Encoding",id:"packed-trit-encoding",level:2},{value:"Sparse Vector Representation",id:"sparse-vector-representation",level:2},{value:"Choosing the Right Format",id:"choosing-the-right-format",level:2},{value:"Impact on Inference",id:"impact-on-inference",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"memory-efficiency",children:"Memory Efficiency"})}),"\n",(0,i.jsx)(t.p,{children:"Trinity achieves up to 20x memory savings compared to float32 representations through a combination of packed ternary encoding, lazy conversion strategies, and sparse vector formats. This page explains each memory optimization technique and when to use it."}),"\n",(0,i.jsx)(t.h2,{id:"ternary-information-density",children:"Ternary Information Density"}),"\n",(0,i.jsx)(t.p,{children:"Each ternary value (trit) can be one of three states: {-1, 0, +1}. This carries log2(3) = 1.58 bits of information. In contrast, a float32 value uses 32 bits, and even a single byte (int8) uses 8 bits. The theoretical minimum storage for a trit is 1.58 bits, and Trinity's packed format approaches this limit."}),"\n",(0,i.jsx)(t.h2,{id:"hybridbigint-dual-representation",children:"HybridBigInt: Dual Representation"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"HybridBigInt"})," type (defined in the core library) provides a hybrid storage strategy with two internal representations:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Packed format"}),": Trits are stored at approximately 1.58 bits per trit using a custom encoding scheme. This is the memory-efficient representation used for storage and transmission."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Unpacked format"}),": Each trit occupies a full integer slot in a fixed-size array (",(0,i.jsx)(t.code,{children:"[MAX_TRITS]Trit"}),"). This is the compute-friendly representation used during arithmetic operations."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Conversion between formats is lazy -- the system only unpacks when an operation requires element-level access, and only packs when storage efficiency is needed. This avoids redundant conversions in operation chains. The ",(0,i.jsx)(t.code,{children:"ensureUnpacked()"})," method is called before JIT-compiled operations to guarantee direct memory access to the trit array."]}),"\n",(0,i.jsx)(t.h2,{id:"packed-trit-encoding",children:"Packed Trit Encoding"}),"\n",(0,i.jsx)(t.p,{children:"At the lowest level, Trinity encodes trits using 2 bits per trit in packed byte arrays. The encoding maps:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Trit Value"}),(0,i.jsx)(t.th,{children:"2-bit Encoding"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"-1"}),(0,i.jsx)(t.td,{children:"0b10"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"0"}),(0,i.jsx)(t.td,{children:"0b00"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"+1"}),(0,i.jsx)(t.td,{children:"0b01"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Four trits fit in a single byte. For a 10,000-dimensional vector:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Format"}),(0,i.jsx)(t.th,{children:"Size"}),(0,i.jsx)(t.th,{children:"Calculation"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"float32"}),(0,i.jsx)(t.td,{children:"40,000 bytes (40 KB)"}),(0,i.jsx)(t.td,{children:"10,000 x 4 bytes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"int8"}),(0,i.jsx)(t.td,{children:"10,000 bytes (10 KB)"}),(0,i.jsx)(t.td,{children:"10,000 x 1 byte"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Packed 2-bit"}),(0,i.jsx)(t.td,{children:"2,500 bytes (2.5 KB)"}),(0,i.jsx)(t.td,{children:"10,000 x 2 bits / 8"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Theoretical (1.58-bit)"}),(0,i.jsx)(t.td,{children:"1,981 bytes (~2 KB)"}),(0,i.jsx)(t.td,{children:"10,000 x 1.58 bits / 8"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"The packed 2-bit format achieves a 16x reduction compared to float32. With the higher-density 1.58 bits/trit packing used by HybridBigInt, the compression approaches 20x."}),"\n",(0,i.jsx)(t.h2,{id:"sparse-vector-representation",children:"Sparse Vector Representation"}),"\n",(0,i.jsxs)(t.p,{children:["For vectors where a large proportion of trits are zero (sparsity > 50%), Trinity provides a ",(0,i.jsx)(t.code,{children:"SparseVector"})," type that uses the Coordinate List (COO) format. Instead of storing every element, it stores only the indices and values of non-zero elements:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"SparseVector {\n    indices: [u32]    -- sorted positions of non-zero trits\n    values:  [Trit]   -- trit values at those positions (-1 or +1)\n    dimension: u32    -- total vector length\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Memory usage scales with the number of non-zero elements (nnz) rather than the total dimension:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Sparsity"}),(0,i.jsx)(t.th,{children:"10,000-dim Dense (packed)"}),(0,i.jsx)(t.th,{children:"10,000-dim Sparse (COO)"}),(0,i.jsx)(t.th,{children:"Savings"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"50% zeros"}),(0,i.jsx)(t.td,{children:"2,500 bytes"}),(0,i.jsx)(t.td,{children:"~25,000 bytes"}),(0,i.jsx)(t.td,{children:"None (sparse is worse)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"90% zeros"}),(0,i.jsx)(t.td,{children:"2,500 bytes"}),(0,i.jsx)(t.td,{children:"~5,000 bytes"}),(0,i.jsx)(t.td,{children:"None (sparse is worse)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"99% zeros"}),(0,i.jsx)(t.td,{children:"2,500 bytes"}),(0,i.jsx)(t.td,{children:"~500 bytes"}),(0,i.jsx)(t.td,{children:"5x"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"99.9% zeros"}),(0,i.jsx)(t.td,{children:"2,500 bytes"}),(0,i.jsx)(t.td,{children:"~50 bytes"}),(0,i.jsx)(t.td,{children:"50x"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["The sparse format becomes advantageous at very high sparsity levels (above ~95% zeros), which occurs in certain VSA encoding patterns and after thresholding operations. The ",(0,i.jsx)(t.code,{children:"SparseVector"})," provides a ",(0,i.jsx)(t.code,{children:"sparsity()"})," method to measure the zero ratio and a ",(0,i.jsx)(t.code,{children:"memorySavings()"})," method to compare against the equivalent dense representation."]}),"\n",(0,i.jsx)(t.h2,{id:"choosing-the-right-format",children:"Choosing the Right Format"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Use Case"}),(0,i.jsx)(t.th,{children:"Recommended Format"}),(0,i.jsx)(t.th,{children:"Reason"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"General VSA operations"}),(0,i.jsx)(t.td,{children:"HybridBigInt (packed)"}),(0,i.jsx)(t.td,{children:"Good balance of memory and speed"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"JIT-compiled hot paths"}),(0,i.jsx)(t.td,{children:"HybridBigInt (unpacked)"}),(0,i.jsx)(t.td,{children:"Direct memory access for native code"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Storage and serialization"}),(0,i.jsx)(t.td,{children:"Packed trit arrays"}),(0,i.jsx)(t.td,{children:"Minimum size for dense vectors"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Very sparse data (>95% zeros)"}),(0,i.jsx)(t.td,{children:"SparseVector (COO)"}),(0,i.jsx)(t.td,{children:"Memory proportional to non-zero count"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"BitNet model weights"}),(0,i.jsx)(t.td,{children:"Packed ternary"}),(0,i.jsx)(t.td,{children:"20x compression vs float32"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"impact-on-inference",children:"Impact on Inference"}),"\n",(0,i.jsx)(t.p,{children:"For BitNet b1.58 language models, the memory savings from ternary weights are substantial. A 7B parameter model in float32 requires approximately 28 GB of memory for weights alone. With ternary packing at 1.58 bits per weight, the same model fits in roughly 1.4 GB -- small enough to run on a single consumer GPU or even in system RAM on a laptop."})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453(e,t,r){r.d(t,{R:()=>o,x:()=>d});var n=r(6540);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);