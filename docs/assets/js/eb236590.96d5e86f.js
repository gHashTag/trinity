"use strict";(globalThis.webpackChunkdocsite=globalThis.webpackChunkdocsite||[]).push([[503],{5001(e,i,n){n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api/jit","title":"JIT Compilation API","description":"VSA operations run in loops over thousands of vector elements. The JIT compiler replaces these loops with native SIMD instructions, processing 16--32 elements per CPU cycle. Result: 15--260x speedup on hot paths. You do not need to understand JIT internals -- just create an engine and call the same operations.","source":"@site/docs/api/jit.md","sourceDirName":"api","slug":"/api/jit","permalink":"/trinity/docs/api/jit","draft":false,"unlisted":false,"editUrl":"https://github.com/gHashTag/trinity/tree/main/docsite/docs/api/jit.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"docsSidebar","previous":{"title":"Sequence HDC API","permalink":"/trinity/docs/api/sequence-hdc"},"next":{"title":"Sparse Vector API","permalink":"/trinity/docs/api/sparse"}}');var s=n(4848),r=n(8453);const d={sidebar_position:9},o="JIT Compilation API",c={},l=[{value:"Do I Need JIT?",id:"do-i-need-jit",level:2},{value:"Expected Speedups",id:"expected-speedups",level:2},{value:"JitVSAEngine",id:"jitvsaengine",level:2},{value:"Construction",id:"construction",level:3},{value:"Methods",id:"methods",level:3},{value:"<code>init(allocator: Allocator) JitVSAEngine</code>",id:"initallocator-allocator-jitvsaengine",level:4},{value:"<code>deinit(self: *JitVSAEngine) void</code>",id:"deinitself-jitvsaengine-void",level:4},{value:"<code>dotProduct(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !i64</code>",id:"dotproductself-jitvsaengine-a-hybridbigint-b-hybridbigint-i64",level:4},{value:"<code>bind(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !void</code>",id:"bindself-jitvsaengine-a-hybridbigint-b-hybridbigint-void",level:4},{value:"<code>bundle(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !void</code>",id:"bundleself-jitvsaengine-a-hybridbigint-b-hybridbigint-void",level:4},{value:"<code>cosineSimilarity(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !f64</code>",id:"cosinesimilarityself-jitvsaengine-a-hybridbigint-b-hybridbigint-f64",level:4},{value:"<code>hammingDistance(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !i64</code>",id:"hammingdistanceself-jitvsaengine-a-hybridbigint-b-hybridbigint-i64",level:4},{value:"<code>permute(self: *JitVSAEngine, v: *HybridBigInt, k: usize) !HybridBigInt</code>",id:"permuteself-jitvsaengine-v-hybridbigint-k-usize-hybridbigint",level:4},{value:"<code>inversePermute(self: *JitVSAEngine, v: *HybridBigInt, k: usize) !HybridBigInt</code>",id:"inversepermuteself-jitvsaengine-v-hybridbigint-k-usize-hybridbigint",level:4},{value:"<code>getStats(self: *JitVSAEngine) Stats</code>",id:"getstatsself-jitvsaengine-stats",level:4},{value:"<code>printStats(self: *JitVSAEngine) void</code>",id:"printstatsself-jitvsaengine-void",level:4},{value:"Stats",id:"stats",level:3},{value:"Platform Support",id:"platform-support",level:2},{value:"Constants",id:"constants",level:2},{value:"Global Convenience Functions",id:"global-convenience-functions",level:2},{value:"<code>initGlobal(allocator: Allocator) void</code>",id:"initglobalallocator-allocator-void",level:4},{value:"<code>deinitGlobal() void</code>",id:"deinitglobal-void",level:4},{value:"<code>jitDotProduct(allocator: Allocator, a: *HybridBigInt, b: *HybridBigInt) !i64</code>",id:"jitdotproductallocator-allocator-a-hybridbigint-b-hybridbigint-i64",level:4},{value:"Complete Example",id:"complete-example",level:2},{value:"Compiler Methods",id:"compiler-methods",level:3}];function a(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Details:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"jit-compilation-api",children:"JIT Compilation API"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.a,{href:"/docs/concepts/glossary",children:"VSA"})," operations run in loops over thousands of vector elements. The JIT compiler replaces these loops with native SIMD instructions, processing 16--32 elements per CPU cycle. Result: ",(0,s.jsx)(i.strong,{children:"15--260x speedup"})," on hot paths. You do not need to understand JIT internals -- just create an engine and call the same operations."]}),"\n",(0,s.jsx)(i.p,{children:"The JIT system compiles specialized machine code for your exact vector dimension at runtime. The first call for a given dimension compiles the function. Every subsequent call reuses the cached native code."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Source files:"})," ",(0,s.jsx)(i.code,{children:"src/vsa_jit.zig"}),", ",(0,s.jsx)(i.code,{children:"src/jit_unified.zig"}),", ",(0,s.jsx)(i.code,{children:"src/jit_arm64.zig"}),", ",(0,s.jsx)(i.code,{children:"src/jit_x86_64.zig"})]}),"\n",(0,s.jsx)(i.h2,{id:"do-i-need-jit",children:"Do I Need JIT?"}),"\n",(0,s.jsx)(i.p,{children:"Not every workload benefits from JIT compilation. Use this guide:"}),"\n",(0,s.jsxs)(i.admonition,{title:"When to enable JIT",type:"tip",children:[(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Yes, use JIT if:"})}),(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"You run many VSA operations in a loop (encoding, querying, training)"}),"\n",(0,s.jsx)(i.li,{children:"Your vector dimension is 1000 or higher"}),"\n",(0,s.jsx)(i.li,{children:"Latency matters (real-time systems, interactive tools)"}),"\n"]}),(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"No, skip JIT if:"})}),(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"You only run a handful of one-off operations"}),"\n",(0,s.jsx)(i.li,{children:"You are prototyping and want simpler debugging"}),"\n",(0,s.jsx)(i.li,{children:"Your vector dimension is under 500 (scalar loops are fast enough)"}),"\n"]})]}),"\n",(0,s.jsx)(i.h2,{id:"expected-speedups",children:"Expected Speedups"}),"\n",(0,s.jsx)(i.p,{children:"Approximate speedups on ARM64 (Apple Silicon / NEON) compared to scalar loops:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Dimension"}),(0,s.jsx)(i.th,{children:"dot product"}),(0,s.jsx)(i.th,{children:"bind"}),(0,s.jsx)(i.th,{children:"cosine"}),(0,s.jsx)(i.th,{children:"permute"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"1000"}),(0,s.jsx)(i.td,{children:"~15x"}),(0,s.jsx)(i.td,{children:"~20x"}),(0,s.jsx)(i.td,{children:"~25x"}),(0,s.jsx)(i.td,{children:"~50x"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"5000"}),(0,s.jsx)(i.td,{children:"~30x"}),(0,s.jsx)(i.td,{children:"~40x"}),(0,s.jsx)(i.td,{children:"~50x"}),(0,s.jsx)(i.td,{children:"~150x"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"10000"}),(0,s.jsx)(i.td,{children:"~50x"}),(0,s.jsx)(i.td,{children:"~50x"}),(0,s.jsx)(i.td,{children:"~60x"}),(0,s.jsx)(i.td,{children:"~260x"})]})]})]}),"\n",(0,s.jsx)(i.p,{children:"Speedups grow with dimension because SIMD amortizes overhead across more elements."}),"\n",(0,s.jsx)(i.admonition,{type:"warning",children:(0,s.jsxs)(i.p,{children:["x86-64 support is ",(0,s.jsx)(i.strong,{children:"partial"}),". Only dot product and bind have SIMD acceleration. All other operations fall back to scalar loops. ARM64 has full SIMD coverage."]})}),"\n",(0,s.jsx)(i.h2,{id:"jitvsaengine",children:"JitVSAEngine"}),"\n",(0,s.jsxs)(i.p,{children:["The primary interface for JIT-accelerated VSA operations. Create one engine per thread (or use the ",(0,s.jsx)(i.a,{href:"#global-convenience-functions",children:"global convenience functions"}),")."]}),"\n",(0,s.jsx)(i.h3,{id:"construction",children:"Construction"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:'const vsa_jit = @import("vsa_jit");\n\nvar engine = vsa_jit.JitVSAEngine.init(allocator);\ndefer engine.deinit();\n'})}),"\n",(0,s.jsx)(i.h3,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(i.h4,{id:"initallocator-allocator-jitvsaengine",children:(0,s.jsx)(i.code,{children:"init(allocator: Allocator) JitVSAEngine"})}),"\n",(0,s.jsx)(i.p,{children:"Creates a new JIT engine with empty caches and zero statistics."}),"\n",(0,s.jsx)(i.h4,{id:"deinitself-jitvsaengine-void",children:(0,s.jsx)(i.code,{children:"deinit(self: *JitVSAEngine) void"})}),"\n",(0,s.jsx)(i.p,{children:"Frees all compiled functions, executable memory, and caches."}),"\n",(0,s.jsx)(i.h4,{id:"dotproductself-jitvsaengine-a-hybridbigint-b-hybridbigint-i64",children:(0,s.jsx)(i.code,{children:"dotProduct(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !i64"})}),"\n",(0,s.jsxs)(i.p,{children:["Computes the ",(0,s.jsx)(i.a,{href:"/docs/concepts/glossary",children:"dot product"})," of two hypervectors using JIT-compiled SIMD code. Vectors are automatically unpacked before the operation. The function compiles on first use for the given dimension and caches for reuse."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"const dot = try engine.dotProduct(&vec_a, &vec_b);\n// dot = 42 (example: sum of element-wise products)\n"})}),"\n",(0,s.jsx)(i.h4,{id:"bindself-jitvsaengine-a-hybridbigint-b-hybridbigint-void",children:(0,s.jsx)(i.code,{children:"bind(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !void"})}),"\n",(0,s.jsxs)(i.p,{children:["Element-wise ternary multiplication (",(0,s.jsx)(i.a,{href:"/docs/concepts/glossary",children:"binding"}),"). ",(0,s.jsxs)(i.strong,{children:["Modifies ",(0,s.jsx)(i.code,{children:"a"})," in place."]})," The result vector ",(0,s.jsx)(i.code,{children:"a"})," is marked dirty so the packed representation recomputes on next access."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"try engine.bind(&vec_a, &vec_b); // vec_a now holds the bound result\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"warning",children:(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"bind"})," modifies the first argument in place. Clone the vector first if you need to keep the original."]})}),"\n",(0,s.jsx)(i.h4,{id:"bundleself-jitvsaengine-a-hybridbigint-b-hybridbigint-void",children:(0,s.jsx)(i.code,{children:"bundle(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !void"})}),"\n",(0,s.jsxs)(i.p,{children:["Element-wise sum with ternary threshold (",(0,s.jsx)(i.a,{href:"/docs/concepts/glossary",children:"bundling"}),"). ",(0,s.jsxs)(i.strong,{children:["Modifies ",(0,s.jsx)(i.code,{children:"a"})," in place."]})," For each position: positive sum becomes ",(0,s.jsx)(i.code,{children:"+1"}),", negative sum becomes ",(0,s.jsx)(i.code,{children:"-1"}),", zero stays ",(0,s.jsx)(i.code,{children:"0"}),"."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"try engine.bundle(&vec_a, &vec_b); // vec_a now holds the bundled result\n"})}),"\n",(0,s.jsx)(i.h4,{id:"cosinesimilarityself-jitvsaengine-a-hybridbigint-b-hybridbigint-f64",children:(0,s.jsx)(i.code,{children:"cosineSimilarity(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !f64"})}),"\n",(0,s.jsxs)(i.p,{children:["Computes cosine similarity using a fused single-pass kernel on ARM64 (2.5x faster than three separate dot products). On x86-64, falls back to computing ",(0,s.jsx)(i.code,{children:"dot(a,b) / sqrt(dot(a,a) * dot(b,b))"})," using three JIT dot product calls."]}),"\n",(0,s.jsxs)(i.p,{children:["Returns a value in the range ",(0,s.jsx)(i.code,{children:"[-1.0, 1.0]"}),"."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"const sim = try engine.cosineSimilarity(&vec_a, &vec_b);\n// sim = 0.0312 (example: near-zero means unrelated random vectors)\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"warning",children:(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Dimension limit:"})," Vectors with dimension above ",(0,s.jsx)(i.code,{children:"MAX_JIT_COSINE_DIM"})," (32768) automatically fall back to the scalar implementation. The SIMD fused kernel has precision constraints at very high dimensions."]})}),"\n",(0,s.jsx)(i.h4,{id:"hammingdistanceself-jitvsaengine-a-hybridbigint-b-hybridbigint-i64",children:(0,s.jsx)(i.code,{children:"hammingDistance(self: *JitVSAEngine, a: *HybridBigInt, b: *HybridBigInt) !i64"})}),"\n",(0,s.jsxs)(i.p,{children:["Counts positions where ",(0,s.jsx)(i.code,{children:"a[i] != b[i]"}),". Uses SIMD comparison on ARM64; scalar fallback on x86-64."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"const dist = try engine.hammingDistance(&vec_a, &vec_b);\n// dist = 667 (example: about 2/3 of elements differ for random vectors)\n"})}),"\n",(0,s.jsx)(i.h4,{id:"permuteself-jitvsaengine-v-hybridbigint-k-usize-hybridbigint",children:(0,s.jsx)(i.code,{children:"permute(self: *JitVSAEngine, v: *HybridBigInt, k: usize) !HybridBigInt"})}),"\n",(0,s.jsxs)(i.p,{children:["Cyclic right shift by ",(0,s.jsx)(i.code,{children:"k"})," positions. Returns a ",(0,s.jsx)(i.strong,{children:"new"})," ",(0,s.jsx)(i.code,{children:"HybridBigInt"})," (does not modify the input). Matches the semantics of ",(0,s.jsx)(i.code,{children:"vsa.permute"}),": ",(0,s.jsx)(i.code,{children:"result[i] = v[(i - k + dim) % dim]"}),"."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"const shifted = try engine.permute(&vec, 5);\n// shifted is a new vector with all elements shifted right by 5\n"})}),"\n",(0,s.jsx)(i.h4,{id:"inversepermuteself-jitvsaengine-v-hybridbigint-k-usize-hybridbigint",children:(0,s.jsx)(i.code,{children:"inversePermute(self: *JitVSAEngine, v: *HybridBigInt, k: usize) !HybridBigInt"})}),"\n",(0,s.jsxs)(i.p,{children:["Cyclic left shift by ",(0,s.jsx)(i.code,{children:"k"})," positions (the inverse of ",(0,s.jsx)(i.code,{children:"permute"}),"). Returns a new ",(0,s.jsx)(i.code,{children:"HybridBigInt"}),"."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"const unshifted = try engine.inversePermute(&shifted, 5);\n// unshifted matches the original vec (roundtrip)\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsxs)(i.p,{children:["Use ",(0,s.jsx)(i.code,{children:"permute"})," and ",(0,s.jsx)(i.code,{children:"inversePermute"})," as a pair to encode and decode position in sequences. They are exact inverses: ",(0,s.jsx)(i.code,{children:"inversePermute(permute(v, k), k) == v"}),"."]})}),"\n",(0,s.jsx)(i.h4,{id:"getstatsself-jitvsaengine-stats",children:(0,s.jsx)(i.code,{children:"getStats(self: *JitVSAEngine) Stats"})}),"\n",(0,s.jsx)(i.p,{children:"Returns current engine statistics."}),"\n",(0,s.jsx)(i.h4,{id:"printstatsself-jitvsaengine-void",children:(0,s.jsx)(i.code,{children:"printStats(self: *JitVSAEngine) void"})}),"\n",(0,s.jsx)(i.p,{children:"Prints formatted statistics to stderr."}),"\n",(0,s.jsx)(i.h3,{id:"stats",children:"Stats"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"pub const Stats = struct {\n    total_ops: u64,     // Total operations performed\n    jit_hits: u64,      // Cache hits (reused compiled function)\n    jit_misses: u64,    // Cache misses (compiled new function)\n    cache_size: usize,  // Total compiled functions across all caches\n    hit_rate: f64,      // Hit rate as percentage (0-100)\n};\n"})}),"\n",(0,s.jsx)(i.h2,{id:"platform-support",children:"Platform Support"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Operation"}),(0,s.jsx)(i.th,{children:"ARM64 (NEON)"}),(0,s.jsx)(i.th,{children:"x86-64 (AVX2)"}),(0,s.jsx)(i.th,{children:"Fallback"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"dotProduct"}),(0,s.jsx)(i.td,{children:"SIMD hybrid"}),(0,s.jsx)(i.td,{children:"AVX2 hybrid"}),(0,s.jsx)(i.td,{children:"Scalar loop"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"bind"}),(0,s.jsx)(i.td,{children:"SIMD"}),(0,s.jsx)(i.td,{children:"Direct scalar"}),(0,s.jsx)(i.td,{children:"Scalar loop"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"bundle"}),(0,s.jsx)(i.td,{children:"SIMD (SMIN/SMAX)"}),(0,s.jsx)(i.td,{children:"Unsupported"}),(0,s.jsx)(i.td,{children:"Scalar loop"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"cosineSimilarity"}),(0,s.jsx)(i.td,{children:"Fused single-pass"}),(0,s.jsx)(i.td,{children:"3x dot products"}),(0,s.jsx)(i.td,{children:"Scalar"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"hammingDistance"}),(0,s.jsx)(i.td,{children:"SIMD"}),(0,s.jsx)(i.td,{children:"Unsupported"}),(0,s.jsx)(i.td,{children:"Scalar loop"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"permute"}),(0,s.jsx)(i.td,{children:"SIMD"}),(0,s.jsx)(i.td,{children:"Unsupported"}),(0,s.jsx)(i.td,{children:"Scalar loop"})]})]})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"ARM64"})," has the most complete SIMD coverage. The fused cosine similarity kernel computes ",(0,s.jsx)(i.code,{children:"dot(a,b)"}),", ",(0,s.jsx)(i.code,{children:"dot(a,a)"}),", and ",(0,s.jsx)(i.code,{children:"dot(b,b)"})," in a single pass, reducing memory bandwidth by 2.5x."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"x86-64"})," currently accelerates dot product and bind only. Other operations use scalar fallbacks. The API stays identical across platforms; only performance differs."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Unsupported architectures"})," (e.g., WASM, RISC-V) use scalar fallbacks for all operations."]}),"\n",(0,s.jsx)(i.h2,{id:"constants",children:"Constants"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Constant"}),(0,s.jsx)(i.th,{children:"Value"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsx)(i.tbody,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"MAX_JIT_COSINE_DIM"})}),(0,s.jsx)(i.td,{children:"32768"}),(0,s.jsx)(i.td,{children:"Maximum dimension for JIT cosine kernel"})]})})]}),"\n",(0,s.jsx)(i.h2,{id:"global-convenience-functions",children:"Global Convenience Functions"}),"\n",(0,s.jsx)(i.p,{children:"Thread-local global engine for simple use cases where managing engine lifetime is not worth the complexity:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:'const vsa_jit = @import("vsa_jit");\n\n// Initialize once per thread\nvsa_jit.initGlobal(allocator);\ndefer vsa_jit.deinitGlobal();\n\n// Use without managing engine lifetime\nconst dot = try vsa_jit.jitDotProduct(allocator, &vec_a, &vec_b);\n// dot = 42 (example)\n'})}),"\n",(0,s.jsx)(i.h4,{id:"initglobalallocator-allocator-void",children:(0,s.jsx)(i.code,{children:"initGlobal(allocator: Allocator) void"})}),"\n",(0,s.jsx)(i.p,{children:"Initializes the thread-local global engine if not already initialized."}),"\n",(0,s.jsx)(i.h4,{id:"deinitglobal-void",children:(0,s.jsx)(i.code,{children:"deinitGlobal() void"})}),"\n",(0,s.jsx)(i.p,{children:"Destroys the thread-local global engine and frees all resources."}),"\n",(0,s.jsx)(i.h4,{id:"jitdotproductallocator-allocator-a-hybridbigint-b-hybridbigint-i64",children:(0,s.jsx)(i.code,{children:"jitDotProduct(allocator: Allocator, a: *HybridBigInt, b: *HybridBigInt) !i64"})}),"\n",(0,s.jsx)(i.p,{children:"Computes dot product using the global engine (initializes it if needed)."}),"\n",(0,s.jsx)(i.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:'const std = @import("std");\nconst vsa = @import("vsa");\nconst vsa_jit = @import("vsa_jit");\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    // Create engine\n    var engine = vsa_jit.JitVSAEngine.init(allocator);\n    defer engine.deinit();\n\n    // Create random test vectors (dimension 2000)\n    var vec_a = vsa.randomVector(2000, 111);\n    var vec_b = vsa.randomVector(2000, 222);\n    var vec_c = vsa.randomVector(2000, 333);\n\n    // JIT dot product (first call compiles, subsequent calls use cache)\n    const dot1 = try engine.dotProduct(&vec_a, &vec_b);\n    const dot2 = try engine.dotProduct(&vec_a, &vec_c);\n    std.debug.print("dot(a,b) = {d}, dot(a,c) = {d}\\n", .{ dot1, dot2 });\n    // dot(a,b) = 14, dot(a,c) = -8 (example values for random vectors)\n\n    // JIT cosine similarity\n    const sim = try engine.cosineSimilarity(&vec_a, &vec_b);\n    std.debug.print("cosine(a,b) = {d:.6}\\n", .{sim});\n    // cosine(a,b) = 0.010500 (example: near-zero for random vectors)\n\n    // JIT bind\n    var bound = vec_a; // copy first -- bind modifies in place\n    try engine.bind(&bound, &vec_b);\n\n    // JIT permute\n    const shifted = try engine.permute(&vec_a, 10);\n    const unshifted = try engine.inversePermute(&shifted, 10);\n\n    // Verify roundtrip\n    const roundtrip_sim = try engine.cosineSimilarity(&vec_a, &unshifted);\n    std.debug.print("permute roundtrip similarity: {d:.6}\\n", .{roundtrip_sim});\n    // permute roundtrip similarity: 1.000000 (exact roundtrip)\n\n    // Print cache statistics\n    engine.printStats();\n}\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example statistics output:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"===============================================================\n              JIT VSA ENGINE STATISTICS\n===============================================================\n  Total operations: 6\n  JIT cache hits:   3\n  JIT cache misses: 3\n  Cache size:       3 functions\n  Hit rate:         50.0%\n===============================================================\n"})}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsx)("summary",{children:"Architecture: Compile-Time Backend Selection"}),(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"jit_unified.zig"})," module detects the CPU architecture at compile time and selects the appropriate backend:"]}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"pub const Architecture = enum {\n    arm64,\n    x86_64,\n    unsupported,\n};\n\npub const current_arch: Architecture = switch (builtin.cpu.arch) {\n    .aarch64 => .arm64,\n    .x86_64 => .x86_64,\n    else => .unsupported,\n};\n\npub const is_jit_supported = current_arch != .unsupported;\n"})}),(0,s.jsx)(i.p,{children:"On unsupported architectures, all JIT operations gracefully fall back to scalar loops."})]}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsx)("summary",{children:"Function Types (C calling convention)"}),(0,s.jsx)(i.p,{children:"JIT-compiled functions use the C calling convention for cross-language compatibility:"}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:"/// JIT dot product: (ptr_a, ptr_b) -> i64\npub const JitDotFn = *const fn (*anyopaque, *anyopaque) callconv(.c) i64;\n\n/// JIT bind: (ptr_a, ptr_b) -> void (modifies a in place)\npub const JitBindFn = *const fn (*anyopaque, *anyopaque) callconv(.c) void;\n"})})]}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsx)("summary",{children:"Caching Strategy"}),(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"JitVSAEngine"})," maintains six separate caches, each keyed by vector dimension (or dimension + shift for permute). Once compiled for a given dimension, functions are reused for all subsequent operations at that dimension."]}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"dot_cache:     dimension -> JitDotFn\nbind_cache:    dimension -> JitDotFn\nhamming_cache: dimension -> JitDotFn\ncosine_cache:  dimension -> JitDotFn\nbundle_cache:  dimension -> JitDotFn\npermute_cache: (dimension, shift) -> JitDotFn\n"})}),(0,s.jsxs)(i.p,{children:["The underlying ",(0,s.jsx)(i.code,{children:"UnifiedJitCompiler"})," instances are stored in an ",(0,s.jsx)(i.code,{children:"ArrayList"})," to keep their executable memory mappings alive for the lifetime of the engine."]})]}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsx)("summary",{children:"UnifiedJitCompiler (Low-Level API)"}),(0,s.jsxs)(i.p,{children:["The low-level compiler interface used internally by ",(0,s.jsx)(i.code,{children:"JitVSAEngine"}),". Most users should use ",(0,s.jsx)(i.code,{children:"JitVSAEngine"})," instead."]}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-zig",children:'const jit_unified = @import("jit_unified");\n\nvar compiler = jit_unified.UnifiedJitCompiler.init(allocator);\ndefer compiler.deinit();\n\n// Compile a dot product for 1000-dimensional vectors\ntry compiler.compileDotProduct(1000);\nconst func = try compiler.finalize();\n\n// Call the compiled function\nconst result = func(a_ptr, b_ptr);\n'})}),(0,s.jsx)(i.h3,{id:"compiler-methods",children:"Compiler Methods"}),(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"init(allocator: Allocator) UnifiedJitCompiler"})," -- Create compiler with architecture-appropriate backend"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"deinit(self: *UnifiedJitCompiler) void"})," -- Free executable memory"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"archName() []const u8"}),' -- Returns human-readable architecture name (e.g., "ARM64 (AArch64)")']}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"hasSIMD() bool"})," -- Whether SIMD instructions are available"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"compileDotProduct(dimension: usize)"})," -- Emit dot product instructions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"compileBind(dimension: usize)"})," -- Emit bind instructions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"compileFusedCosine(dimension: usize)"})," -- Emit fused cosine (ARM64 only, returns ",(0,s.jsx)(i.code,{children:"error.UnsupportedOperation"})," on x86-64)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"compileHamming(dimension: usize)"})," -- Emit hamming distance (ARM64 only)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"compileBundleSIMD(dimension: usize)"})," -- Emit bundle with SMIN/SMAX (ARM64 only)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"compilePermute(dimension: usize, shift: usize)"})," -- Emit cyclic shift (ARM64 only)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"finalize() !JitDotFn"})," -- Finalize and return executable function pointer"]}),"\n"]})]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453(e,i,n){n.d(i,{R:()=>d,x:()=>o});var t=n(6540);const s={},r=t.createContext(s);function d(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);