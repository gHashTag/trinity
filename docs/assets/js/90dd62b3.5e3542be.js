"use strict";(globalThis.webpackChunkdocsite=globalThis.webpackChunkdocsite||[]).push([[2593],{1508(e,i,n){n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"benchmarks/jit-performance","title":"JIT Compilation Performance","description":"Trinity includes a custom Just-In-Time (JIT) compiler that generates native machine code for VSA (Vector Symbolic Architecture) operations at runtime. This provides a 15-260x speedup over interpreted Zig execution for hot-path operations.","source":"@site/docs/benchmarks/jit-performance.md","sourceDirName":"benchmarks","slug":"/benchmarks/jit-performance","permalink":"/trinity/docs/benchmarks/jit-performance","draft":false,"unlisted":false,"editUrl":"https://github.com/gHashTag/trinity/tree/main/docsite/docs/benchmarks/jit-performance.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"GPU Inference Benchmarks","permalink":"/trinity/docs/benchmarks/gpu-inference"},"next":{"title":"Memory Efficiency","permalink":"/trinity/docs/benchmarks/memory-efficiency"}}');var r=n(4848),c=n(8453);const s={sidebar_position:3},o="JIT Compilation Performance",d={},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"JIT-Compiled Operations",id:"jit-compiled-operations",level:2},{value:"Caching Strategy",id:"caching-strategy",level:2},{value:"ARM64 Backend",id:"arm64-backend",level:2},{value:"x86-64 Backend",id:"x86-64-backend",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Fallback Behavior",id:"fallback-behavior",level:2}];function a(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"jit-compilation-performance",children:"JIT Compilation Performance"})}),"\n",(0,r.jsx)(i.p,{children:"Trinity includes a custom Just-In-Time (JIT) compiler that generates native machine code for VSA (Vector Symbolic Architecture) operations at runtime. This provides a 15-260x speedup over interpreted Zig execution for hot-path operations."}),"\n",(0,r.jsx)(i.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(i.p,{children:"The JIT system consists of three layers:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"vsa_jit.zig"})})," -- The JIT VSA engine that manages compiled function caches and provides the high-level API"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"jit_arm64.zig"})})," -- ARM64 (AArch64) backend that emits native ARM instructions"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"jit_x86_64.zig"})})," -- x86-64 backend that emits native Intel/AMD instructions"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"jit_unified.zig"})})," -- Unified interface that selects the correct backend at compile time"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"The system detects the host platform at compile time and selects the appropriate backend. On unsupported architectures, operations fall back to the standard interpreted Zig implementation."}),"\n",(0,r.jsx)(i.h2,{id:"jit-compiled-operations",children:"JIT-Compiled Operations"}),"\n",(0,r.jsx)(i.p,{children:"The following VSA operations are compiled to native machine code:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Operation"}),(0,r.jsx)(i.th,{children:"Description"}),(0,r.jsx)(i.th,{children:"Typical Speedup"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"dotProduct"})}),(0,r.jsx)(i.td,{children:"Inner product of two ternary vectors"}),(0,r.jsx)(i.td,{children:"15-50x"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"bind"})}),(0,r.jsx)(i.td,{children:"Element-wise ternary multiplication (association)"}),(0,r.jsx)(i.td,{children:"20-80x"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"bundle"})}),(0,r.jsx)(i.td,{children:"Majority vote across vectors"}),(0,r.jsx)(i.td,{children:"25-100x"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"hammingDistance"})}),(0,r.jsx)(i.td,{children:"Count of differing trit positions"}),(0,r.jsx)(i.td,{children:"15-60x"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"cosineSimilarity"})}),(0,r.jsx)(i.td,{children:"Normalized dot product"}),(0,r.jsx)(i.td,{children:"20-70x"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"permute"})}),(0,r.jsx)(i.td,{children:"Cyclic shift of vector elements"}),(0,r.jsx)(i.td,{children:"50-260x"})]})]})]}),"\n",(0,r.jsx)(i.p,{children:"Speedup factors vary depending on vector dimension, platform, and whether SIMD instructions are available."}),"\n",(0,r.jsx)(i.h2,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"JitVSAEngine"})," maintains separate caches for each operation type and vector dimension:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"dot_cache:      dimension -> compiled function\nbind_cache:     dimension -> compiled function\nhamming_cache:  dimension -> compiled function\ncosine_cache:   dimension -> compiled function\nbundle_cache:   dimension -> compiled function\npermute_cache:  (dimension, shift) -> compiled function\n"})}),"\n",(0,r.jsxs)(i.p,{children:["When an operation is first called for a given dimension, the JIT compiler generates native code and stores the resulting function pointer. Subsequent calls with the same dimension execute the cached native code directly, incurring only the cost of a function pointer call. The engine tracks cache hit/miss statistics (",(0,r.jsx)(i.code,{children:"jit_hits"}),", ",(0,r.jsx)(i.code,{children:"jit_misses"}),", ",(0,r.jsx)(i.code,{children:"total_ops"}),") for profiling."]}),"\n",(0,r.jsx)(i.h2,{id:"arm64-backend",children:"ARM64 Backend"}),"\n",(0,r.jsxs)(i.p,{children:["The ARM64 backend (",(0,r.jsx)(i.code,{children:"jit_arm64.zig"}),") targets AArch64 processors including:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Apple Silicon (M1, M2, M3, M4 series)"}),"\n",(0,r.jsx)(i.li,{children:"AWS Graviton processors"}),"\n",(0,r.jsx)(i.li,{children:"Raspberry Pi 4/5 (64-bit mode)"}),"\n",(0,r.jsx)(i.li,{children:"Ampere Altra server CPUs"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"It emits 32-bit fixed-width ARM instructions using standard calling conventions. Key features include:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Store/load pair instructions (STP/LDP) for efficient stack management"}),"\n",(0,r.jsx)(i.li,{children:"Callee-saved register allocation (x19-x24) for complex operations"}),"\n",(0,r.jsxs)(i.li,{children:["16KB page-aligned executable memory allocation via ",(0,r.jsx)(i.code,{children:"mmap"}),"/",(0,r.jsx)(i.code,{children:"mprotect"})]}),"\n",(0,r.jsx)(i.li,{children:"Direct register encoding for all ARM64 general-purpose registers (x0-x30)"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"x86-64-backend",children:"x86-64 Backend"}),"\n",(0,r.jsxs)(i.p,{children:["The x86-64 backend (",(0,r.jsx)(i.code,{children:"jit_x86_64.zig"}),") targets Intel and AMD processors. It emits variable-length x86 instructions using the System V AMD64 ABI. Key features include:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Standard prologue/epilogue with frame pointer (push rbp / mov rbp, rsp)"}),"\n",(0,r.jsx)(i.li,{children:"32-bit and 64-bit immediate encoding"}),"\n",(0,r.jsxs)(i.li,{children:["Page-aligned executable memory via ",(0,r.jsx)(i.code,{children:"mmap"}),"/",(0,r.jsx)(i.code,{children:"mprotect"})]}),"\n",(0,r.jsx)(i.li,{children:"REX prefix support for 64-bit register operations"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsx)(i.p,{children:"The JIT compilation flow for a dot product operation:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"engine.dotProduct(&a, &b)"})," is called"]}),"\n",(0,r.jsxs)(i.li,{children:["The engine checks ",(0,r.jsx)(i.code,{children:"dot_cache"})," for a compiled function matching the vector dimension"]}),"\n",(0,r.jsxs)(i.li,{children:["On cache miss, a new ",(0,r.jsx)(i.code,{children:"UnifiedJitCompiler"})," is created"]}),"\n",(0,r.jsx)(i.li,{children:"The compiler emits native instructions for the dot product loop"}),"\n",(0,r.jsx)(i.li,{children:"The compiled code is placed in executable memory (mmap with PROT_EXEC)"}),"\n",(0,r.jsx)(i.li,{children:"The function pointer is cached and called"}),"\n",(0,r.jsx)(i.li,{children:"The HybridBigInt vectors are unpacked to their raw trit arrays for direct memory access"}),"\n",(0,r.jsx)(i.li,{children:"The native function operates directly on the unpacked trit data"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"fallback-behavior",children:"Fallback Behavior"}),"\n",(0,r.jsx)(i.p,{children:"If JIT compilation fails or the platform is unsupported, the engine falls back to the standard Zig VSA implementation. This ensures correctness across all platforms while providing acceleration where native code generation is available."})]})}function h(e={}){const{wrapper:i}={...(0,c.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453(e,i,n){n.d(i,{R:()=>s,x:()=>o});var t=n(6540);const r={},c=t.createContext(r);function s(e){const i=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(c.Provider,{value:i},e.children)}}}]);