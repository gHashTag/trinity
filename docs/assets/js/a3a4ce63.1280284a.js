"use strict";(globalThis.webpackChunkdocsite=globalThis.webpackChunkdocsite||[]).push([[8125],{1691(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"api/sparse","title":"Sparse Vector API","description":"When most elements in your vector are zero, storing all of them wastes memory. SparseVector stores only the non-zero elements with their positions. For a 10,000-element vector with 90% zeros, this saves 10x memory and makes operations 10x faster.","source":"@site/docs/api/sparse.md","sourceDirName":"api","slug":"/api/sparse","permalink":"/trinity/docs/api/sparse","draft":false,"unlisted":false,"editUrl":"https://github.com/gHashTag/trinity/tree/main/docsite/docs/api/sparse.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"docsSidebar","previous":{"title":"JIT Compilation API","permalink":"/trinity/docs/api/jit"},"next":{"title":"Architecture Overview","permalink":"/trinity/docs/architecture/overview"}}');var t=n(4848),o=n(8453);const i={sidebar_position:10},a="Sparse Vector API",c={},d=[{value:"When to Use Sparse vs Dense",id:"when-to-use-sparse-vs-dense",level:2},{value:"Density After Operations",id:"density-after-operations",level:2},{value:"SparseVector",id:"sparsevector",level:2},{value:"Construction",id:"construction",level:3},{value:"<code>init(allocator: Allocator, dimension: u32) SparseVector</code>",id:"initallocator-allocator-dimension-u32-sparsevector",level:4},{value:"<code>deinit(self: *SparseVector) void</code>",id:"deinitself-sparsevector-void",level:4},{value:"<code>random(allocator: Allocator, dimension: u32, density: f64, seed: u64) !SparseVector</code>",id:"randomallocator-allocator-dimension-u32-density-f64-seed-u64-sparsevector",level:4},{value:"<code>fromDense(allocator: Allocator, dense: *HybridBigInt) !SparseVector</code>",id:"fromdenseallocator-allocator-dense-hybridbigint-sparsevector",level:4},{value:"<code>toDense(self: *const SparseVector) HybridBigInt</code>",id:"todenseself-const-sparsevector-hybridbigint",level:4},{value:"<code>clone(self: *const SparseVector) !SparseVector</code>",id:"cloneself-const-sparsevector-sparsevector",level:4},{value:"Element Access",id:"element-access",level:3},{value:"<code>set(self: *SparseVector, index: u32, value: Trit) !void</code>",id:"setself-sparsevector-index-u32-value-trit-void",level:4},{value:"<code>get(self: *const SparseVector, index: u32) Trit</code>",id:"getself-const-sparsevector-index-u32-trit",level:4},{value:"Properties",id:"properties",level:3},{value:"<code>nnz(self: *const SparseVector) usize</code>",id:"nnzself-const-sparsevector-usize",level:4},{value:"<code>sparsity(self: *const SparseVector) f64</code>",id:"sparsityself-const-sparsevector-f64",level:4},{value:"<code>memoryBytes(self: *const SparseVector) usize</code>",id:"memorybytesself-const-sparsevector-usize",level:4},{value:"<code>memorySavings(self: *const SparseVector) f64</code>",id:"memorysavingsself-const-sparsevector-f64",level:4},{value:"VSA Operations",id:"vsa-operations",level:2},{value:"<code>bind(allocator: Allocator, a: *const SparseVector, b: *const SparseVector) !SparseVector</code>",id:"bindallocator-allocator-a-const-sparsevector-b-const-sparsevector-sparsevector",level:3},{value:"<code>unbind(allocator: Allocator, a: *const SparseVector, b: *const SparseVector) !SparseVector</code>",id:"unbindallocator-allocator-a-const-sparsevector-b-const-sparsevector-sparsevector",level:3},{value:"<code>bundle(allocator: Allocator, a: *const SparseVector, b: *const SparseVector) !SparseVector</code>",id:"bundleallocator-allocator-a-const-sparsevector-b-const-sparsevector-sparsevector",level:3},{value:"<code>permute(allocator: Allocator, v: *const SparseVector, k: u32) !SparseVector</code>",id:"permuteallocator-allocator-v-const-sparsevector-k-u32-sparsevector",level:3},{value:"Similarity",id:"similarity",level:2},{value:"<code>dot(a: *const SparseVector, b: *const SparseVector) i64</code>",id:"dota-const-sparsevector-b-const-sparsevector-i64",level:3},{value:"<code>cosineSimilarity(a: *const SparseVector, b: *const SparseVector) f64</code>",id:"cosinesimilaritya-const-sparsevector-b-const-sparsevector-f64",level:3},{value:"<code>hammingDistance(a: *const SparseVector, b: *const SparseVector) usize</code>",id:"hammingdistancea-const-sparsevector-b-const-sparsevector-usize",level:3},{value:"Memory Complexity",id:"memory-complexity",level:2},{value:"Complete Example",id:"complete-example",level:2}];function l(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{Details:n}=s;return n||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"sparse-vector-api",children:"Sparse Vector API"})}),"\n",(0,t.jsxs)(s.p,{children:["When most elements in your vector are zero, storing all of them wastes memory. ",(0,t.jsx)(s.code,{children:"SparseVector"})," stores only the non-zero elements with their positions. For a 10,000-element vector with 90% zeros, this saves 10x memory and makes operations 10x faster."]}),"\n",(0,t.jsxs)(s.p,{children:["Trinity uses ",(0,t.jsx)(s.a,{href:"/docs/concepts/glossary",children:"ternary vectors"})," ({-1, 0, +1}). Many operations -- masking, gating, thresholding -- produce vectors dominated by zeros. ",(0,t.jsx)(s.code,{children:"SparseVector"})," exploits this by keeping two sorted arrays: indices (where non-zero elements live) and values (what those elements are). All lookups use binary search. All VSA operations use merge-join algorithms that skip zeros entirely."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Source:"})," ",(0,t.jsx)(s.code,{children:"src/sparse.zig"})]}),"\n",(0,t.jsx)(s.h2,{id:"when-to-use-sparse-vs-dense",children:"When to Use Sparse vs Dense"}),"\n",(0,t.jsx)(s.admonition,{title:"Rule of thumb",type:"tip",children:(0,t.jsxs)(s.p,{children:["Use ",(0,t.jsx)(s.code,{children:"SparseVector"})," when more than half your elements are zero. Below 50% zeros, the index overhead negates the memory savings."]})}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Density"}),(0,t.jsx)(s.th,{children:"Memory (10K dim)"}),(0,t.jsx)(s.th,{children:"bind speed"}),(0,t.jsx)(s.th,{children:"Recommendation"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"5% non-zero"}),(0,t.jsx)(s.td,{children:"Sparse: ~2.5KB vs Dense: ~10KB"}),(0,t.jsx)(s.td,{children:"Sparse ~20x faster"}),(0,t.jsx)(s.td,{children:"Use Sparse"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"33% non-zero"}),(0,t.jsx)(s.td,{children:"Sparse: ~16KB vs Dense: ~10KB"}),(0,t.jsx)(s.td,{children:"Similar"}),(0,t.jsx)(s.td,{children:"Use Dense"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"66% non-zero"}),(0,t.jsx)(s.td,{children:"Sparse: ~33KB vs Dense: ~10KB"}),(0,t.jsx)(s.td,{children:"Dense ~2x faster"}),(0,t.jsx)(s.td,{children:"Use Dense"})]})]})]}),"\n",(0,t.jsx)(s.admonition,{type:"warning",children:(0,t.jsxs)(s.p,{children:["JIT operations require dense vectors. Convert with ",(0,t.jsx)(s.code,{children:"toDense()"})," before passing to ",(0,t.jsx)(s.code,{children:"JitVSAEngine"}),". See the ",(0,t.jsx)(s.a,{href:"/trinity/docs/api/jit",children:"JIT API"})," for details."]})}),"\n",(0,t.jsx)(s.h2,{id:"density-after-operations",children:"Density After Operations"}),"\n",(0,t.jsx)(s.p,{children:"Different VSA operations change the density of your vectors. Plan accordingly:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Operation"}),(0,t.jsx)(s.th,{children:"Output density"}),(0,t.jsx)(s.th,{children:"Explanation"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"bind"})}),(0,t.jsx)(s.td,{children:"density_a x density_b"}),(0,t.jsxs)(s.td,{children:["Only positions where ",(0,t.jsx)(s.em,{children:"both"})," inputs are non-zero survive. Output is always sparser."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"bundle"})}),(0,t.jsx)(s.td,{children:"density_a + density_b - overlap"}),(0,t.jsxs)(s.td,{children:["Positions from ",(0,t.jsx)(s.em,{children:"either"})," input survive. Output is usually denser."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"permute"})}),(0,t.jsx)(s.td,{children:"Same as input"}),(0,t.jsx)(s.td,{children:"Elements just move to new positions. No zeros are created or removed."})]})]})]}),"\n",(0,t.jsx)(s.p,{children:"For example, binding two 10%-dense vectors produces roughly 1%-dense output (0.1 x 0.1 = 0.01). Bundling two 10%-dense vectors produces roughly 19%-dense output (0.1 + 0.1 - 0.01 = 0.19)."}),"\n",(0,t.jsx)(s.h2,{id:"sparsevector",children:"SparseVector"}),"\n",(0,t.jsx)(s.h3,{id:"construction",children:"Construction"}),"\n",(0,t.jsx)(s.h4,{id:"initallocator-allocator-dimension-u32-sparsevector",children:(0,t.jsx)(s.code,{children:"init(allocator: Allocator, dimension: u32) SparseVector"})}),"\n",(0,t.jsx)(s.p,{children:"Creates an empty sparse vector with the given total dimension. No memory is allocated until elements are added."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:'const sparse = @import("sparse");\n\nvar vec = sparse.SparseVector.init(allocator, 10000);\ndefer vec.deinit();\n'})}),"\n",(0,t.jsx)(s.h4,{id:"deinitself-sparsevector-void",children:(0,t.jsx)(s.code,{children:"deinit(self: *SparseVector) void"})}),"\n",(0,t.jsx)(s.p,{children:"Frees the internal index and value arrays."}),"\n",(0,t.jsx)(s.h4,{id:"randomallocator-allocator-dimension-u32-density-f64-seed-u64-sparsevector",children:(0,t.jsx)(s.code,{children:"random(allocator: Allocator, dimension: u32, density: f64, seed: u64) !SparseVector"})}),"\n",(0,t.jsx)(s.p,{children:"Creates a random sparse vector with the specified density (fraction of non-zero elements). Non-zero values are uniformly chosen as +1 or -1."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"// 10% density: ~1000 non-zero elements in a 10000-dim vector\nvar vec = try sparse.SparseVector.random(allocator, 10000, 0.10, 42);\ndefer vec.deinit();\n// vec.nnz() = ~1000\n"})}),"\n",(0,t.jsx)(s.h4,{id:"fromdenseallocator-allocator-dense-hybridbigint-sparsevector",children:(0,t.jsx)(s.code,{children:"fromDense(allocator: Allocator, dense: *HybridBigInt) !SparseVector"})}),"\n",(0,t.jsxs)(s.p,{children:["Converts a dense ",(0,t.jsx)(s.code,{children:"HybridBigInt"})," to sparse representation. Iterates over all elements and stores only non-zero trits."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"var dense_vec = vsa.randomVector(1000, 42);\nvar sparse_vec = try sparse.SparseVector.fromDense(allocator, &dense_vec);\ndefer sparse_vec.deinit();\n// sparse_vec.nnz() = ~667 (random ternary vectors are ~66% non-zero)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"todenseself-const-sparsevector-hybridbigint",children:(0,t.jsx)(s.code,{children:"toDense(self: *const SparseVector) HybridBigInt"})}),"\n",(0,t.jsxs)(s.p,{children:["Converts back to a dense ",(0,t.jsx)(s.code,{children:"HybridBigInt"}),". Initializes all positions to zero, then sets non-zero values from the sparse representation. Returns a stack-allocated ",(0,t.jsx)(s.code,{children:"HybridBigInt"}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const dense = sparse_vec.toDense();\n// dense is a full HybridBigInt with all dimensions filled in\n"})}),"\n",(0,t.jsx)(s.h4,{id:"cloneself-const-sparsevector-sparsevector",children:(0,t.jsx)(s.code,{children:"clone(self: *const SparseVector) !SparseVector"})}),"\n",(0,t.jsx)(s.p,{children:"Creates an independent copy of the sparse vector."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"var copy = try vec.clone();\ndefer copy.deinit();\n"})}),"\n",(0,t.jsx)(s.h3,{id:"element-access",children:"Element Access"}),"\n",(0,t.jsx)(s.h4,{id:"setself-sparsevector-index-u32-value-trit-void",children:(0,t.jsx)(s.code,{children:"set(self: *SparseVector, index: u32, value: Trit) !void"})}),"\n",(0,t.jsx)(s.p,{children:"Sets the value at the given index. Uses binary search to find the insertion point."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"If the value is non-zero and the index is new, inserts in sorted order."}),"\n",(0,t.jsx)(s.li,{children:"If the value is non-zero and the index exists, updates in place."}),"\n",(0,t.jsx)(s.li,{children:"If the value is zero and the index exists, removes the element (maintains sparsity)."}),"\n",(0,t.jsxs)(s.li,{children:["If the index is out of bounds (at or above ",(0,t.jsx)(s.code,{children:"dimension"}),"), the operation is silently ignored."]}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"try vec.set(42, 1);    // Set position 42 to +1\ntry vec.set(100, -1);  // Set position 100 to -1\ntry vec.set(42, 0);    // Remove position 42 (now zero)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"getself-const-sparsevector-index-u32-trit",children:(0,t.jsx)(s.code,{children:"get(self: *const SparseVector, index: u32) Trit"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns the trit value at the given index. Uses binary search. Returns ",(0,t.jsx)(s.code,{children:"0"})," for positions not in the sparse representation or for out-of-bounds indices."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const val = vec.get(42);  // Returns -1, 0, or +1\n"})}),"\n",(0,t.jsx)(s.h3,{id:"properties",children:"Properties"}),"\n",(0,t.jsx)(s.h4,{id:"nnzself-const-sparsevector-usize",children:(0,t.jsx)(s.code,{children:"nnz(self: *const SparseVector) usize"})}),"\n",(0,t.jsx)(s.p,{children:"Returns the number of non-zero elements."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const count = vec.nnz();\n// count = 1000 (for a 10%-dense, 10000-dim vector)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"sparsityself-const-sparsevector-f64",children:(0,t.jsx)(s.code,{children:"sparsity(self: *const SparseVector) f64"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns the sparsity ratio: ",(0,t.jsx)(s.code,{children:"1.0 - nnz/dimension"}),". A value of 0.0 means all elements are non-zero; 1.0 means all elements are zero."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const s = vec.sparsity();\n// s = 0.90 (90% of elements are zero)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"memorybytesself-const-sparsevector-usize",children:(0,t.jsx)(s.code,{children:"memoryBytes(self: *const SparseVector) usize"})}),"\n",(0,t.jsx)(s.p,{children:"Returns current memory usage in bytes, including struct overhead and the index/value arrays."}),"\n",(0,t.jsx)(s.h4,{id:"memorysavingsself-const-sparsevector-f64",children:(0,t.jsx)(s.code,{children:"memorySavings(self: *const SparseVector) f64"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns the memory savings ratio compared to a dense representation: ",(0,t.jsx)(s.code,{children:"1.0 - sparse_bytes/dense_bytes"}),". A value of 0.8 means the sparse representation uses 80% less memory."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const savings = vec.memorySavings();\n// savings = 0.80 (80% less memory than dense)\n"})}),"\n",(0,t.jsx)(s.h2,{id:"vsa-operations",children:"VSA Operations"}),"\n",(0,t.jsxs)(s.p,{children:["All VSA operations allocate and return a new ",(0,t.jsx)(s.code,{children:"SparseVector"}),". The caller owns the result and must call ",(0,t.jsx)(s.code,{children:"deinit"})," when done."]}),"\n",(0,t.jsx)(s.h3,{id:"bindallocator-allocator-a-const-sparsevector-b-const-sparsevector-sparsevector",children:(0,t.jsx)(s.code,{children:"bind(allocator: Allocator, a: *const SparseVector, b: *const SparseVector) !SparseVector"})}),"\n",(0,t.jsxs)(s.p,{children:["Element-wise ternary multiplication using a merge-join on sorted indices. The result contains elements only at positions where ",(0,t.jsx)(s.strong,{children:"both"})," inputs have non-zero values. The result is always at least as sparse as the sparser input."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"var bound = try sparse.SparseVector.bind(allocator, &vec_a, &vec_b);\ndefer bound.deinit();\n// bound.nnz() = ~100 (for two 10%-dense inputs: 0.1 * 0.1 * 10000)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"unbindallocator-allocator-a-const-sparsevector-b-const-sparsevector-sparsevector",children:(0,t.jsx)(s.code,{children:"unbind(allocator: Allocator, a: *const SparseVector, b: *const SparseVector) !SparseVector"})}),"\n",(0,t.jsxs)(s.p,{children:["Identical to ",(0,t.jsx)(s.code,{children:"bind"})," for balanced ternary. Multiplying by the inverse is the same as multiplying by the value itself when values come from {-1, 0, +1}."]}),"\n",(0,t.jsx)(s.h3,{id:"bundleallocator-allocator-a-const-sparsevector-b-const-sparsevector-sparsevector",children:(0,t.jsx)(s.code,{children:"bundle(allocator: Allocator, a: *const SparseVector, b: *const SparseVector) !SparseVector"})}),"\n",(0,t.jsxs)(s.p,{children:["Element-wise sum with ternary threshold. Unlike bind, the result may be ",(0,t.jsx)(s.strong,{children:"denser"})," than the inputs because positions where only one input is non-zero survive. At positions where both inputs are non-zero, the sum is thresholded: positive becomes +1, negative becomes -1, zero is omitted."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"var bundled = try sparse.SparseVector.bundle(allocator, &vec_a, &vec_b);\ndefer bundled.deinit();\n// bundled.nnz() = ~1900 (denser than either input)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"permuteallocator-allocator-v-const-sparsevector-k-u32-sparsevector",children:(0,t.jsx)(s.code,{children:"permute(allocator: Allocator, v: *const SparseVector, k: u32) !SparseVector"})}),"\n",(0,t.jsxs)(s.p,{children:["Cyclic shift of all indices by ",(0,t.jsx)(s.code,{children:"k"})," positions: ",(0,t.jsx)(s.code,{children:"new_index = (old_index + k) % dimension"}),". Values are unchanged. The result is re-sorted by index after shifting."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"var shifted = try sparse.SparseVector.permute(allocator, &vec, 5);\ndefer shifted.deinit();\n// shifted.nnz() == vec.nnz() (same density, different positions)\n"})}),"\n",(0,t.jsx)(s.h2,{id:"similarity",children:"Similarity"}),"\n",(0,t.jsx)(s.p,{children:"Similarity functions are static methods that do not allocate memory."}),"\n",(0,t.jsx)(s.h3,{id:"dota-const-sparsevector-b-const-sparsevector-i64",children:(0,t.jsx)(s.code,{children:"dot(a: *const SparseVector, b: *const SparseVector) i64"})}),"\n",(0,t.jsx)(s.p,{children:"Sparse dot product using merge-join. Only positions present in both vectors contribute to the sum. Runs in O(nnz_a + nnz_b) time."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const d = sparse.SparseVector.dot(&vec_a, &vec_b);\n// d = 12 (example: sum of element-wise products at shared positions)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"cosinesimilaritya-const-sparsevector-b-const-sparsevector-f64",children:(0,t.jsx)(s.code,{children:"cosineSimilarity(a: *const SparseVector, b: *const SparseVector) f64"})}),"\n",(0,t.jsxs)(s.p,{children:["Cosine similarity: ",(0,t.jsx)(s.code,{children:"dot(a,b) / (||a|| * ||b||)"}),". For ternary vectors, ",(0,t.jsx)(s.code,{children:"||v||^2 = nnz(v)"})," since all non-zero values are +/-1. Returns 0.0 if either vector is the zero vector."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const sim = sparse.SparseVector.cosineSimilarity(&vec_a, &vec_b);\n// sim = 0.012 (example: near-zero for random sparse vectors)\n"})}),"\n",(0,t.jsx)(s.h3,{id:"hammingdistancea-const-sparsevector-b-const-sparsevector-usize",children:(0,t.jsx)(s.code,{children:"hammingDistance(a: *const SparseVector, b: *const SparseVector) usize"})}),"\n",(0,t.jsxs)(s.p,{children:["Counts positions where ",(0,t.jsx)(s.code,{children:"a[i] != b[i]"}),". This includes:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Positions where both are non-zero but differ in value"}),"\n",(0,t.jsx)(s.li,{children:"Positions where one is non-zero and the other is zero (implicitly)"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Uses merge-join to efficiently compare only the non-zero regions."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:"const dist = sparse.SparseVector.hammingDistance(&vec_a, &vec_b);\n// dist = 1800 (example: most non-zero positions differ for random vectors)\n"})}),"\n",(0,t.jsx)(s.h2,{id:"memory-complexity",children:"Memory Complexity"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Representation"}),(0,t.jsx)(s.th,{children:"Memory"}),(0,t.jsx)(s.th,{children:"Bind Cost"}),(0,t.jsx)(s.th,{children:"Dot Product Cost"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:["Dense (",(0,t.jsx)(s.code,{children:"HybridBigInt"}),")"]}),(0,t.jsx)(s.td,{children:"O(dimension)"}),(0,t.jsx)(s.td,{children:"O(dimension)"}),(0,t.jsx)(s.td,{children:"O(dimension)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:["Sparse (",(0,t.jsx)(s.code,{children:"SparseVector"}),")"]}),(0,t.jsx)(s.td,{children:"O(nnz)"}),(0,t.jsx)(s.td,{children:"O(nnz_a + nnz_b)"}),(0,t.jsx)(s.td,{children:"O(nnz_a + nnz_b)"})]})]})]}),"\n",(0,t.jsx)(s.p,{children:"For a 10,000-dimensional vector with 500 non-zero elements (95% sparse), the sparse representation uses approximately 20x less memory."}),"\n",(0,t.jsx)(s.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-zig",children:'const std = @import("std");\nconst sparse = @import("sparse");\nconst vsa = @import("vsa");\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    // Create sparse vectors with 10% density\n    var vec_a = try sparse.SparseVector.random(allocator, 10000, 0.10, 111);\n    defer vec_a.deinit();\n\n    var vec_b = try sparse.SparseVector.random(allocator, 10000, 0.10, 222);\n    defer vec_b.deinit();\n\n    // Check properties\n    std.debug.print("vec_a: nnz={d}, sparsity={d:.2}%, memory={d} bytes\\n", .{\n        vec_a.nnz(),\n        vec_a.sparsity() * 100.0,\n        vec_a.memoryBytes(),\n    });\n    // vec_a: nnz=1000, sparsity=90.00%, memory=5024 bytes\n\n    std.debug.print("Memory savings vs dense: {d:.1}%\\n", .{\n        vec_a.memorySavings() * 100.0,\n    });\n    // Memory savings vs dense: 87.5%\n\n    // Sparse bind (result is sparser than inputs)\n    var bound = try sparse.SparseVector.bind(allocator, &vec_a, &vec_b);\n    defer bound.deinit();\n    std.debug.print("bind result: nnz={d} (expected ~{d})\\n", .{\n        bound.nnz(),\n        @as(usize, @intFromFloat(0.10 * 0.10 * 10000.0)),\n    });\n    // bind result: nnz=98 (expected ~100)\n\n    // Similarity\n    const sim = sparse.SparseVector.cosineSimilarity(&vec_a, &vec_b);\n    std.debug.print("cosine similarity: {d:.6}\\n", .{sim});\n    // cosine similarity: 0.012345\n\n    // Convert to dense for JIT operations\n    const dense_a = vec_a.toDense();\n    _ = dense_a;\n\n    // Convert dense back to sparse\n    var dense_vec = vsa.randomVector(1000, 42);\n    var sparse_from_dense = try sparse.SparseVector.fromDense(allocator, &dense_vec);\n    defer sparse_from_dense.deinit();\n    std.debug.print("Dense->sparse roundtrip: nnz={d}, sparsity={d:.2}%\\n", .{\n        sparse_from_dense.nnz(),\n        sparse_from_dense.sparsity() * 100.0,\n    });\n    // Dense->sparse roundtrip: nnz=667, sparsity=33.30%\n}\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Internal Details"}),(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Sorted indices:"})," The ",(0,t.jsx)(s.code,{children:"indices"})," array is always maintained in ascending sorted order. This invariant enables binary search for ",(0,t.jsx)(s.code,{children:"get"}),"/",(0,t.jsx)(s.code,{children:"set"})," and merge-join for VSA operations."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Insertion sort after permute:"})," After cyclic shifting, indices may become unsorted. The ",(0,t.jsx)(s.code,{children:"permute"})," function uses insertion sort to restore order, which is efficient for nearly-sorted data."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"No packed mode:"})," Unlike ",(0,t.jsx)(s.code,{children:"HybridBigInt"}),", sparse vectors do not use bit-packed representation. The overhead of packing/unpacking would negate the sparse access benefits."]}),"\n"]})]})]})}function p(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453(e,s,n){n.d(s,{R:()=>i,x:()=>a});var r=n(6540);const t={},o=r.createContext(t);function i(e){const s=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(o.Provider,{value:s},e.children)}}}]);