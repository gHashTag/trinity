"use strict";(globalThis.webpackChunkdocsite=globalThis.webpackChunkdocsite||[]).push([[8591],{4302(e){e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","href":"/trinity/docs/","label":"Trinity Documentation","docId":"intro","unlisted":false},{"type":"category","label":"Overview","items":[{"type":"link","href":"/trinity/docs/overview/introduction","label":"Trinity: Ternary Computing Platform","docId":"overview/introduction","unlisted":false},{"type":"link","href":"/trinity/docs/overview/roadmap","label":"Roadmap","docId":"overview/roadmap","unlisted":false},{"type":"link","href":"/trinity/docs/overview/tech-tree","label":"Technology Tree","docId":"overview/tech-tree","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Getting Started","items":[{"type":"link","href":"/trinity/docs/getting-started/quickstart","label":"Quick Start","docId":"getting-started/quickstart","unlisted":false},{"type":"link","href":"/trinity/docs/getting-started/tutorial","label":"Tutorial: Build a Semantic Memory","docId":"getting-started/tutorial","unlisted":false},{"type":"link","href":"/trinity/docs/getting-started/installation","label":"Installation","docId":"getting-started/installation","unlisted":false},{"type":"link","href":"/trinity/docs/getting-started/development-setup","label":"Development Setup","docId":"getting-started/development-setup","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Concepts","items":[{"type":"link","href":"/trinity/docs/concepts/","label":"Ternary Computing Concepts","docId":"concepts/index","unlisted":false},{"type":"link","href":"/trinity/docs/concepts/balanced-ternary","label":"Balanced Ternary Arithmetic","docId":"concepts/balanced-ternary","unlisted":false},{"type":"link","href":"/trinity/docs/concepts/trinity-identity","label":"The Trinity Identity","docId":"concepts/trinity-identity","unlisted":false},{"type":"link","href":"/trinity/docs/concepts/glossary","label":"Glossary","docId":"concepts/glossary","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"BitNet Integration","items":[{"type":"link","href":"/trinity/docs/bitnet/","label":"BitNet Integration","docId":"bitnet/index","unlisted":false},{"type":"link","href":"/trinity/docs/bitnet/inference","label":"Inference Pipeline","docId":"bitnet/inference","unlisted":false},{"type":"link","href":"/trinity/docs/bitnet/model-format","label":"GGUF Model Format","docId":"bitnet/model-format","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"HDC Applications","items":[{"type":"link","href":"/trinity/docs/hdc/","label":"Hyperdimensional Computing","docId":"hdc/index","unlisted":false},{"type":"link","href":"/trinity/docs/hdc/applications","label":"HDC Applications","docId":"hdc/applications","unlisted":false},{"type":"link","href":"/trinity/docs/hdc/igla-glove-comparison","label":"IGLA GloVe Competitor Comparison","docId":"hdc/igla-glove-comparison","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"VIBEE Language","items":[{"type":"link","href":"/trinity/docs/vibee/","label":"VIBEE Language","docId":"vibee/index","unlisted":false},{"type":"link","href":"/trinity/docs/vibee/specification","label":"VIBEE Specification Format","docId":"vibee/specification","unlisted":false},{"type":"link","href":"/trinity/docs/vibee/examples","label":"VIBEE Examples","docId":"vibee/examples","unlisted":false},{"type":"link","href":"/trinity/docs/vibee/theorems","label":"Theorems","docId":"vibee/theorems","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Benchmarks","items":[{"type":"link","href":"/trinity/docs/benchmarks/","label":"Benchmarks","docId":"benchmarks/index","unlisted":false},{"type":"link","href":"/trinity/docs/benchmarks/gpu-inference","label":"GPU Inference Benchmarks","docId":"benchmarks/gpu-inference","unlisted":false},{"type":"link","href":"/trinity/docs/benchmarks/jit-performance","label":"JIT Compilation Performance","docId":"benchmarks/jit-performance","unlisted":false},{"type":"link","href":"/trinity/docs/benchmarks/memory-efficiency","label":"Memory Efficiency","docId":"benchmarks/memory-efficiency","unlisted":false},{"type":"link","href":"/trinity/docs/benchmarks/competitor-comparison","label":"Competitor Comparison","docId":"benchmarks/competitor-comparison","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Deployment","items":[{"type":"link","href":"/trinity/docs/deployment/","label":"Deployment","docId":"deployment/index","unlisted":false},{"type":"link","href":"/trinity/docs/deployment/runpod","label":"RunPod GPU Deployment","docId":"deployment/runpod","unlisted":false},{"type":"link","href":"/trinity/docs/deployment/local","label":"Local Deployment","docId":"deployment/local","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"link","href":"/trinity/docs/api/","label":"Overview","docId":"api/index","unlisted":false},{"type":"link","href":"/trinity/docs/api/vsa","label":"VSA API","docId":"api/vsa","unlisted":false},{"type":"link","href":"/trinity/docs/api/vm","label":"VM API","docId":"api/vm","unlisted":false},{"type":"link","href":"/trinity/docs/api/hybrid","label":"Hybrid API","docId":"api/hybrid","unlisted":false},{"type":"link","href":"/trinity/docs/api/firebird","label":"Firebird API","docId":"api/firebird","unlisted":false},{"type":"link","href":"/trinity/docs/api/vibee","label":"VIBEE API","docId":"api/vibee","unlisted":false},{"type":"link","href":"/trinity/docs/api/plugin","label":"Plugin API","docId":"api/plugin","unlisted":false},{"type":"link","href":"/trinity/docs/api/sequence-hdc","label":"Sequence HDC API","docId":"api/sequence-hdc","unlisted":false},{"type":"link","href":"/trinity/docs/api/jit","label":"JIT Compilation API","docId":"api/jit","unlisted":false},{"type":"link","href":"/trinity/docs/api/sparse","label":"Sparse Vector API","docId":"api/sparse","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Architecture","items":[{"type":"link","href":"/trinity/docs/architecture/overview","label":"Architecture Overview","docId":"architecture/overview","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Mathematical Foundations","items":[{"type":"link","href":"/trinity/docs/math-foundations/","label":"Overview","docId":"math-foundations/index","unlisted":false},{"type":"link","href":"/trinity/docs/math-foundations/formulas","label":"Formulas","docId":"math-foundations/formulas","unlisted":false},{"type":"link","href":"/trinity/docs/math-foundations/proofs","label":"Proofs","docId":"math-foundations/proofs","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Research","items":[{"type":"link","href":"/trinity/docs/research/","label":"Research and References","docId":"research/index","unlisted":false},{"type":"link","href":"/trinity/docs/research/bitnet-report","label":"BitNet b1.58 Coherence Report","docId":"research/bitnet-report","unlisted":false},{"type":"link","href":"/trinity/docs/research/trinity-node-ffi","label":"Trinity Node BitNet FFI Integration","docId":"research/trinity-node-ffi","unlisted":false},{"type":"link","href":"/trinity/docs/research/bibliography","label":"Scientific Bibliography","docId":"research/bibliography","unlisted":false},{"type":"link","href":"/trinity/docs/research/references","label":"Scientific References","docId":"research/references","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"link","href":"/trinity/docs/faq","label":"FAQ","docId":"faq","unlisted":false},{"type":"link","href":"/trinity/docs/troubleshooting","label":"Troubleshooting","docId":"troubleshooting","unlisted":false},{"type":"link","href":"/trinity/docs/contributing","label":"Contributing to Trinity","docId":"contributing","unlisted":false}]},"docs":{"api/firebird":{"id":"api/firebird","title":"Firebird API","description":"LLM Inference Engine with BitNet Support.","sidebar":"docsSidebar"},"api/hybrid":{"id":"api/hybrid","title":"Hybrid API","description":"HybridBigInt \u2014 Optimal Memory/Speed Trade-off.","sidebar":"docsSidebar"},"api/index":{"id":"api/index","title":"API Reference","description":"Complete API documentation for Trinity modules.","sidebar":"docsSidebar"},"api/jit":{"id":"api/jit","title":"JIT Compilation API","description":"VSA operations run in loops over thousands of vector elements. The JIT compiler replaces these loops with native SIMD instructions, processing 16--32 elements per CPU cycle. Result: 15--260x speedup on hot paths. You do not need to understand JIT internals -- just create an engine and call the same operations.","sidebar":"docsSidebar"},"api/plugin":{"id":"api/plugin","title":"Plugin API","description":"Extensible Plugin System for Trinity.","sidebar":"docsSidebar"},"api/sequence-hdc":{"id":"api/sequence-hdc","title":"Sequence HDC API","description":"This module turns text into vectors. Feed it strings like \\"hello world\\", and it produces compact numeric vectors that capture the text\'s pattern. Similar texts produce similar vectors. Use it for language detection, text classification, or semantic search -- without training a neural network.","sidebar":"docsSidebar"},"api/sparse":{"id":"api/sparse","title":"Sparse Vector API","description":"When most elements in your vector are zero, storing all of them wastes memory. SparseVector stores only the non-zero elements with their positions. For a 10,000-element vector with 90% zeros, this saves 10x memory and makes operations 10x faster.","sidebar":"docsSidebar"},"api/vibee":{"id":"api/vibee","title":"VIBEE API","description":"Specification-Driven Code Generator.","sidebar":"docsSidebar"},"api/vm":{"id":"api/vm","title":"VM API","description":"Ternary Virtual Machine for Hyperdimensional Computing.","sidebar":"docsSidebar"},"api/vsa":{"id":"api/vsa","title":"VSA API","description":"Vector Symbolic Architecture for Balanced Ternary Computing.","sidebar":"docsSidebar"},"architecture/agents-v2":{"id":"architecture/agents-v2","title":"AGENTS.md V2.0 - PHI-LOCKED PROTOCOL","description":"Overview"},"architecture/bogatyrs-decomposition":{"id":"architecture/bogatyrs-decomposition","title":"33 BOGATYRS DECOMPOSITION - PHASE 2.2","description":"SYNTAX SQUAD (5 bogatyrs)"},"architecture/overview":{"id":"architecture/overview","title":"Architecture Overview","description":"Trinity is built on three core principles:","sidebar":"docsSidebar"},"benchmarks/competitor-comparison":{"id":"benchmarks/competitor-comparison","title":"Competitor Comparison","description":"How Trinity BitNet compares to industry alternatives in performance, cost, and energy efficiency.","sidebar":"docsSidebar"},"benchmarks/e2e-test-results":{"id":"benchmarks/e2e-test-results","title":"Trinity CLI E2E Test Results","description":"Test Summary"},"benchmarks/gpu-inference":{"id":"benchmarks/gpu-inference","title":"GPU Inference Benchmarks","description":"BitNet b1.58 models use ternary weights (\\\\{-1, 0, +1\\\\}), enabling highly efficient inference on both consumer and datacenter GPUs. This page summarizes performance measurements across different hardware configurations.","sidebar":"docsSidebar"},"benchmarks/index":{"id":"benchmarks/index","title":"Benchmarks","description":"Trinity is a high-performance ternary computing framework built in Zig, designed for both Vector Symbolic Architecture (VSA) operations and large language model inference using BitNet b1.58 ternary weights. This section provides an overview of Trinity\'s performance characteristics across several key dimensions.","sidebar":"docsSidebar"},"benchmarks/jit-performance":{"id":"benchmarks/jit-performance","title":"JIT Compilation Performance","description":"Trinity includes a custom Just-In-Time (JIT) compiler that generates native machine code for VSA (Vector Symbolic Architecture) operations at runtime. This provides a 15-260x speedup over interpreted Zig execution for hot-path operations.","sidebar":"docsSidebar"},"benchmarks/memory-efficiency":{"id":"benchmarks/memory-efficiency","title":"Memory Efficiency","description":"Trinity achieves up to 20x memory savings compared to float32 representations through a combination of packed ternary encoding, lazy conversion strategies, and sparse vector formats. This page explains each memory optimization technique and when to use it.","sidebar":"docsSidebar"},"bitnet/index":{"id":"bitnet/index","title":"BitNet Integration","description":"What is BitNet b1.58?","sidebar":"docsSidebar"},"bitnet/inference":{"id":"bitnet/inference","title":"Inference Pipeline","description":"This page provides a detailed walkthrough of how BitNet inference works in Trinity, from loading a model file to generating text output. The entire pipeline is implemented natively in Zig with zero external dependencies.","sidebar":"docsSidebar"},"bitnet/model-format":{"id":"bitnet/model-format","title":"GGUF Model Format","description":"Trinity reads model weights from GGUF (GPT-Generated Unified Format) files, the standard format used by the llama.cpp ecosystem. This page documents how Trinity parses GGUF v3 files and what model configurations are supported.","sidebar":"docsSidebar"},"concepts/balanced-ternary":{"id":"concepts/balanced-ternary","title":"Balanced Ternary Arithmetic","description":"Trits and Bits","sidebar":"docsSidebar"},"concepts/glossary":{"id":"concepts/glossary","title":"Glossary","description":"Quick reference for terms used throughout Trinity documentation. If a term is missing, check the API Reference for module-specific definitions.","sidebar":"docsSidebar"},"concepts/index":{"id":"concepts/index","title":"Ternary Computing Concepts","description":"Why Ternary?","sidebar":"docsSidebar"},"concepts/trinity-identity":{"id":"concepts/trinity-identity","title":"The Trinity Identity","description":"Statement","sidebar":"docsSidebar"},"contributing":{"id":"contributing","title":"Contributing to Trinity","description":"Thank you for your interest in contributing to Trinity. This guide covers everything you need to know -- from our specification-first philosophy to the 16-step development cycle.","sidebar":"docsSidebar"},"deployment/index":{"id":"deployment/index","title":"Deployment","description":"Trinity supports multiple deployment configurations depending on your hardware, use case, and performance requirements. This section covers the primary deployment options.","sidebar":"docsSidebar"},"deployment/local":{"id":"deployment/local","title":"Local Deployment","description":"Run Trinity on your local machine for development, testing, and inference with ternary models. This guide covers building from source, running inference, and using the CLI tools.","sidebar":"docsSidebar"},"deployment/runpod":{"id":"deployment/runpod","title":"RunPod GPU Deployment","description":"RunPod provides on-demand GPU instances suitable for high-throughput BitNet b1.58 inference. This guide walks through deploying Trinity on a RunPod instance for benchmarking and production inference.","sidebar":"docsSidebar"},"faq":{"id":"faq","title":"FAQ","description":"Frequently asked questions about the Trinity framework.","sidebar":"docsSidebar"},"getting-started/development-setup":{"id":"getting-started/development-setup","title":"Development Setup","description":"Configure your development environment for Trinity.","sidebar":"docsSidebar"},"getting-started/installation":{"id":"getting-started/installation","title":"Installation","description":"Complete installation guide for Trinity.","sidebar":"docsSidebar"},"getting-started/quickstart":{"id":"getting-started/quickstart","title":"Quick Start","description":"Get up and running with Trinity in 5 minutes.","sidebar":"docsSidebar"},"getting-started/tutorial":{"id":"getting-started/tutorial","title":"Tutorial: Build a Semantic Memory","description":"Learn Trinity\'s core operations by building a simple knowledge store that can answer questions.","sidebar":"docsSidebar"},"hdc/applications":{"id":"hdc/applications","title":"HDC Applications","description":"Trinity includes 23 Hyperdimensional Computing application modules, each defined as a .vibee specification in the specs/tri/ directory. These modules cover a broad range of machine learning and AI tasks, all implemented using the same ternary Vector Symbolic Architecture operations -- no gradient descent, no backpropagation, and no floating-point weight matrices.","sidebar":"docsSidebar"},"hdc/igla-glove-comparison":{"id":"hdc/igla-glove-comparison","title":"IGLA GloVe Competitor Comparison","description":"How Trinity\'s IGLA (HDC/VSA zero-shot with GloVe ternary) compares to traditional word embedding systems for semantic reasoning tasks.","sidebar":"docsSidebar"},"hdc/index":{"id":"hdc/index","title":"Hyperdimensional Computing","description":"What is HDC / VSA?","sidebar":"docsSidebar"},"intro":{"id":"intro","title":"Trinity Documentation","description":"Welcome to Trinity \u2014 a Ternary Computing Framework with VSA, BitNet LLM inference, and VIBEE compiler.","sidebar":"docsSidebar"},"math-foundations/formulas":{"id":"math-foundations/formulas","title":"Constant Approximation Formulas","description":"Physical constants approximated through a parametric form and related ternary identities.","sidebar":"docsSidebar"},"math-foundations/index":{"id":"math-foundations/index","title":"Mathematical Foundations","description":"Trinity\'s mathematical foundation rests on properties of the golden ratio, information-theoretic optimality of the ternary base, and parametric approximation of physical constants. The ternary system \\\\{-1, 0, +1\\\\} is chosen for its provably optimal radix economy among integer bases.","sidebar":"docsSidebar"},"math-foundations/proofs":{"id":"math-foundations/proofs","title":"Mathematical Proofs","description":"Rigorous derivations of Trinity\'s core mathematical results, with proper theorem numbering and references.","sidebar":"docsSidebar"},"overview/introduction":{"id":"overview/introduction","title":"Trinity: Ternary Computing Platform","description":"Sacred Formula: \u03c6\xb2 + 1/\u03c6\xb2 = 3 = TRINITY","sidebar":"docsSidebar"},"overview/roadmap":{"id":"overview/roadmap","title":"Roadmap","description":"Current Status: v2.0 (February 2026)","sidebar":"docsSidebar"},"overview/tech-tree":{"id":"overview/tech-tree","title":"Technology Tree","description":"Interactive Architecture","sidebar":"docsSidebar"},"research/bibliography":{"id":"research/bibliography","title":"Scientific Bibliography","description":"Comprehensive list of academic papers and publications that form the scientific foundation of Trinity. All claims in the documentation are backed by peer-reviewed research.","sidebar":"docsSidebar"},"research/bitnet-report":{"id":"research/bitnet-report","title":"BitNet b1.58 Coherence Report","description":"Authors: Trinity Research Team","sidebar":"docsSidebar"},"research/cycle27-import-integration-report":{"id":"research/cycle27-import-integration-report","title":"Cycle 27: @import Integration Report","description":"Status 65/65 | Improvement Rate: 1.0"},"research/cycle28-real-vsa-calls-report":{"id":"research/cycle28-real-vsa-calls-report","title":"Cycle 28: Real VSA Calls Report","description":"Status 65/65 | Improvement Rate: 1.0"},"research/cycle29-text-encoding-report":{"id":"research/cycle29-text-encoding-report","title":"Cycle 29: Text \u2194 Vector Encoding Report","description":"Status 69/69 | Improvement Rate: 1.0"},"research/cycle30-semantic-similarity-report":{"id":"research/cycle30-semantic-similarity-report","title":"Cycle 30: Semantic Similarity Search Report","description":"Status 72/72 | Improvement Rate: 1.0"},"research/cycle31-persistent-corpus-report":{"id":"research/cycle31-persistent-corpus-report","title":"Cycle 31: Persistent Corpus Storage","description":"Status: IMMORTAL"},"research/cycle32-compressed-corpus-report":{"id":"research/cycle32-compressed-corpus-report","title":"Cycle 32: Compressed Corpus Format","description":"Status: IMMORTAL"},"research/cycle33-adaptive-rle-report":{"id":"research/cycle33-adaptive-rle-report","title":"Cycle 33: Adaptive RLE Compression","description":"Status: IMMORTAL"},"research/cycle34-dictionary-compression-report":{"id":"research/cycle34-dictionary-compression-report","title":"Cycle 34: Dictionary Compression","description":"Status: IMMORTAL"},"research/cycle35-huffman-compression-report":{"id":"research/cycle35-huffman-compression-report","title":"Cycle 35: Huffman Compression","description":"Status: IMMORTAL"},"research/cycle36-arithmetic-compression-report":{"id":"research/cycle36-arithmetic-compression-report","title":"Cycle 36: Arithmetic Coding Compression","description":"Status: IMMORTAL"},"research/cycle37-corpus-sharding-report":{"id":"research/cycle37-corpus-sharding-report","title":"Cycle 37: Corpus Sharding","description":"Status: IMMORTAL"},"research/cycle38-parallel-loading-report":{"id":"research/cycle38-parallel-loading-report","title":"Cycle 38: Parallel Loading","description":"Status: IMMORTAL"},"research/index":{"id":"research/index","title":"Research and References","description":"Trinity draws on several active research areas spanning machine learning, neuroscience-inspired computing, information theory, and ternary arithmetic. This page provides an overview of the foundational work and key publications behind the framework.","sidebar":"docsSidebar"},"research/references":{"id":"research/references","title":"Scientific References","description":"Core Theory","sidebar":"docsSidebar"},"research/status":{"id":"research/status","title":"Trinity Project Status - Honest Assessment","description":"Last Updated: 2026-02-06"},"research/trinity-node-ffi":{"id":"research/trinity-node-ffi","title":"Trinity Node BitNet FFI Integration","description":"Authors: Trinity Research Team","sidebar":"docsSidebar"},"troubleshooting":{"id":"troubleshooting","title":"Troubleshooting","description":"Common issues and solutions.","sidebar":"docsSidebar"},"vibee/examples":{"id":"vibee/examples","title":"VIBEE Examples","description":"Practical examples of .vibee specifications for different use cases.","sidebar":"docsSidebar"},"vibee/index":{"id":"vibee/index","title":"VIBEE Language","description":"VIBEE (VIBrant Erlang Ecosystem) is Trinity\'s specification-driven code generation language. Write specifications once, generate code for 42+ languages.","sidebar":"docsSidebar"},"vibee/specification":{"id":"vibee/specification","title":"VIBEE Specification Format","description":"Complete reference for .vibee specification files.","sidebar":"docsSidebar"},"vibee/theorems":{"id":"vibee/theorems","title":"VIBEE Theorems and Proofs","description":"VIBEE\'s formal verification is backed by 33 proven theorems establishing correctness, efficiency, and coverage. All theorems are constructive -- they come with proofs and empirical evidence.","sidebar":"docsSidebar"}}}}')}}]);