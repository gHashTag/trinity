"use strict";(globalThis.webpackChunkdocsite=globalThis.webpackChunkdocsite||[]).push([[9856],{1062(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"concepts/balanced-ternary","title":"Balanced Ternary Arithmetic","description":"Trits and Bits","source":"@site/docs/concepts/balanced-ternary.md","sourceDirName":"concepts","slug":"/concepts/balanced-ternary","permalink":"/trinity/docs/concepts/balanced-ternary","draft":false,"unlisted":false,"editUrl":"https://github.com/gHashTag/trinity/tree/main/docsite/docs/concepts/balanced-ternary.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Ternary Computing Concepts","permalink":"/trinity/docs/concepts/"},"next":{"title":"The Trinity Identity","permalink":"/trinity/docs/concepts/trinity-identity"}}');var r=i(4848),s=i(8453);const d={sidebar_position:2},a="Balanced Ternary Arithmetic",l={},c=[{value:"Trits and Bits",id:"trits-and-bits",level:2},{value:"Balanced vs. Unbalanced Ternary",id:"balanced-vs-unbalanced-ternary",level:2},{value:"Basic Arithmetic Operations",id:"basic-arithmetic-operations",level:2},{value:"Ternary Addition",id:"ternary-addition",level:3},{value:"Ternary Multiplication",id:"ternary-multiplication",level:3},{value:"Negation",id:"negation",level:3},{value:"Ternary Encoding in Trinity",id:"ternary-encoding-in-trinity",level:2},{value:"Comparison with Binary",id:"comparison-with-binary",level:2},{value:"Applications in Trinity",id:"applications-in-trinity",level:2},{value:"Further Reading",id:"further-reading",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"balanced-ternary-arithmetic",children:"Balanced Ternary Arithmetic"})}),"\n",(0,r.jsx)(n.h2,{id:"trits-and-bits",children:"Trits and Bits"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"trit"})," (ternary digit) is the fundamental unit of ternary computing. While a binary digit (bit) can represent two states (0 or 1), a trit represents three states. In ",(0,r.jsx)(n.strong,{children:"balanced ternary"}),", these states are {-1, 0, +1}, often written as {T, 0, 1} or {-, 0, +} for brevity."]}),"\n",(0,r.jsx)(n.p,{children:"The information content of a single trit is log2(3) = 1.585 bits. This means each trit carries approximately 58.5% more information than a single bit. To represent the same range of N values, you need ceiling(log3(N)) trits versus ceiling(log2(N)) bits -- fewer symbols, each doing more work."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Unit"}),(0,r.jsx)(n.th,{children:"States"}),(0,r.jsx)(n.th,{children:"Information Content"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Bit"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"1.000 bits"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Trit"}),(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"1.585 bits"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"balanced-vs-unbalanced-ternary",children:"Balanced vs. Unbalanced Ternary"}),"\n",(0,r.jsx)(n.p,{children:"Standard (unbalanced) ternary uses the digit set {0, 1, 2}, analogous to how binary uses {0, 1}. Balanced ternary instead uses {-1, 0, +1}, centering the digit values symmetrically around zero. This seemingly small change has profound consequences:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Signed numbers need no special encoding."})," In binary, representing negative numbers requires conventions like two's complement. In balanced ternary, negative numbers arise naturally -- the number -5 in balanced ternary is simply the negation of +5, obtained by flipping every trit."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No wasted representations."})," Two's complement binary has an asymmetry: an n-bit number can represent one more negative value than positive. Balanced ternary with n trits represents values symmetrically from -(3^n - 1)/2 to +(3^n - 1)/2."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Truncation equals rounding."})," Dropping the least significant trits of a balanced ternary number rounds to the nearest representable value, not toward zero as in binary."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-arithmetic-operations",children:"Basic Arithmetic Operations"}),"\n",(0,r.jsx)(n.h3,{id:"ternary-addition",children:"Ternary Addition"}),"\n",(0,r.jsx)(n.p,{children:"Addition in balanced ternary follows the same column-by-column logic as binary addition, but with three possible values per position. The addition table:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"+"}),(0,r.jsx)(n.th,{children:"-1"}),(0,r.jsx)(n.th,{children:"0"}),(0,r.jsx)(n.th,{children:"+1"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"-1"}),(0,r.jsx)(n.td,{children:"-1, carry -1"}),(0,r.jsx)(n.td,{children:"-1"}),(0,r.jsx)(n.td,{children:"0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"-1"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"+1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"+1"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"+1"}),(0,r.jsx)(n.td,{children:"+1, carry +1"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:'When the sum of two trits exceeds +1 or falls below -1, a carry propagates to the next position. For example, (+1) + (+1) = -1 with a carry of +1 (since 1 + 1 = 2, and 2 in balanced ternary is "1T", meaning +1 in the next position and -1 in the current position).'}),"\n",(0,r.jsx)(n.h3,{id:"ternary-multiplication",children:"Ternary Multiplication"}),"\n",(0,r.jsx)(n.p,{children:"Multiplication by a single trit is trivial:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"x"}),(0,r.jsx)(n.th,{children:"-1"}),(0,r.jsx)(n.th,{children:"0"}),(0,r.jsx)(n.th,{children:"+1"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"-1"}),(0,r.jsx)(n.td,{children:"+1"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"-1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"+1"}),(0,r.jsx)(n.td,{children:"-1"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"+1"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"This is standard integer multiplication restricted to {-1, 0, +1}:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Multiplying by ",(0,r.jsx)(n.strong,{children:"+1"})," leaves the value unchanged (identity)."]}),"\n",(0,r.jsxs)(n.li,{children:["Multiplying by ",(0,r.jsx)(n.strong,{children:"-1"})," negates the value (sign flip)."]}),"\n",(0,r.jsxs)(n.li,{children:["Multiplying by ",(0,r.jsx)(n.strong,{children:"0"})," produces zero (annihilation)."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This property is critical for neural network inference. When model weights are ternary, matrix-vector multiplication reduces to additions and subtractions -- no floating-point multipliers are needed."}),"\n",(0,r.jsx)(n.h3,{id:"negation",children:"Negation"}),"\n",(0,r.jsx)(n.p,{children:"To negate a balanced ternary number, flip the sign of every trit:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  +1  0 -1 +1    (the number +7 in balanced ternary)\n  -1  0 +1 -1    (the number -7 -- just flip all signs)\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is simpler than binary negation (which requires inverting all bits and adding one) and never produces edge cases or overflow."}),"\n",(0,r.jsx)(n.h2,{id:"ternary-encoding-in-trinity",children:"Ternary Encoding in Trinity"}),"\n",(0,r.jsxs)(n.p,{children:["Trinity represents trits in memory using a compact ",(0,r.jsx)(n.strong,{children:"packed encoding"})," that stores each trit in 2 bits. The mapping is:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Trit Value"}),(0,r.jsx)(n.th,{children:"2-bit Encoding"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"-1 (T)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"00"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"01"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"+1"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"10"})})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"This encoding uses 2 bits per trit, achieving an effective density of 1.585 / 2 = 79.3% of the theoretical maximum. While not perfectly optimal (the theoretical minimum is log2(3) = 1.585 bits per trit), the 2-bit encoding enables fast bitwise operations and aligns naturally with byte boundaries."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"/docs/api/hybrid",children:"HybridBigInt"})," type in Trinity manages this encoding transparently. It maintains two representations: a ",(0,r.jsx)(n.strong,{children:"packed"})," form for memory-efficient storage and an ",(0,r.jsx)(n.strong,{children:"unpacked"})," form (an array of individual trit values) for fast computation. Conversions between the two are performed lazily -- only when needed -- and are cached to avoid redundant work."]}),"\n",(0,r.jsx)(n.p,{children:"With this encoding, a 256-trit vector (a common dimension in Trinity's VSA operations) occupies just 64 bytes in packed form, compared to 256 bytes if each trit were stored in a full byte, or 1024 bytes if stored as 32-bit floats."}),"\n",(0,r.jsx)(n.h2,{id:"comparison-with-binary",children:"Comparison with Binary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Property"}),(0,r.jsx)(n.th,{children:"Binary"}),(0,r.jsx)(n.th,{children:"Balanced Ternary"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Digit values"}),(0,r.jsx)(n.td,{children:"{0, 1}"}),(0,r.jsx)(n.td,{children:"{-1, 0, +1}"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Info per digit"}),(0,r.jsx)(n.td,{children:"1.000 bits"}),(0,r.jsx)(n.td,{children:"1.585 bits"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Radix economy"}),(0,r.jsx)(n.td,{children:"2.885 (94.7%)"}),(0,r.jsx)(n.td,{children:"2.731 (100%)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Negation"}),(0,r.jsx)(n.td,{children:"Invert + add 1"}),(0,r.jsx)(n.td,{children:"Flip all signs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Signed numbers"}),(0,r.jsx)(n.td,{children:"Two's complement"}),(0,r.jsx)(n.td,{children:"Native"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Truncation"}),(0,r.jsx)(n.td,{children:"Rounds toward zero"}),(0,r.jsx)(n.td,{children:"Rounds to nearest"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Multiplication"}),(0,r.jsx)(n.td,{children:"Full multiply"}),(0,r.jsx)(n.td,{children:"Add/subtract only (for single trit)"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"applications-in-trinity",children:"Applications in Trinity"}),"\n",(0,r.jsx)(n.p,{children:"The balanced ternary representation is the foundation of every subsystem in Trinity:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"VSA operations"})," (",(0,r.jsx)(n.a,{href:"/docs/api/vsa",children:"bind, unbind, bundle"}),") operate element-wise on ternary vectors. Binding uses trit multiplication; unbinding is identical to binding (the operation is its own inverse for non-zero trits)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BitNet inference"})," (",(0,r.jsx)(n.a,{href:"/docs/api/firebird",children:"Firebird"}),") quantizes LLM weights to {-1, 0, +1}, turning matrix multiplications into accumulations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"The Ternary VM"})," (",(0,r.jsx)(n.a,{href:"/docs/api/vm",children:"VM"}),") executes bytecode with a ternary instruction set, operating on ternary stack values."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/concepts",children:"Ternary Computing Concepts"})," -- overview and motivation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/concepts/trinity-identity",children:"The Trinity Identity"})," -- why the golden ratio connects to base-3"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/api/vsa",children:"VSA API Reference"})," -- ternary vector operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/api/hybrid",children:"HybridBigInt API Reference"})," -- packed trit storage"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453(e,n,i){i.d(n,{R:()=>d,x:()=>a});var t=i(6540);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);