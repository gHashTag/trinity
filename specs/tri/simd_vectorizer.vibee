name: simd_vectorizer
version: "1.0.0"
language: zig
module: simd_vectorizer

description: |
  SIMD Vectorization Pass for SSA IR
  Detects vectorizable patterns and converts scalar ops to SIMD
  Target: 4-8x speedup for array operations
  Sacred Formula: V = n × 3^k × π^m × φ^p × e^q

constants:
  PHI: 1.618033988749895
  VECTOR_WIDTH_8: 32
  VECTOR_WIDTH_16: 16
  VECTOR_WIDTH_32: 8
  VECTOR_WIDTH_64: 4
  MIN_VECTORIZE_LENGTH: 4

types:
  VectorWidth:
    description: SIMD vector width enum
    variants:
      - Width8   # 32 x i8
      - Width16  # 16 x i16
      - Width32  # 8 x i32
      - Width64  # 4 x i64

  VectorOp:
    description: Vectorized SSA operation
    variants:
      - vec_add
      - vec_sub
      - vec_mul
      - vec_div
      - vec_neg
      - vec_load
      - vec_store
      - vec_splat
      - vec_reduce_add
      - vec_reduce_mul

  VectorInstr:
    description: SIMD instruction in SSA form
    fields:
      op: VectorOp
      dest: Int
      src1: Int
      src2: Int
      width: VectorWidth
      lane_count: Int

  LoopInfo:
    description: Loop analysis for vectorization
    fields:
      start_block: Int
      end_block: Int
      iteration_count: Int
      induction_var: Int
      stride: Int
      is_vectorizable: Bool

  VectorizationResult:
    description: Result of vectorization pass
    fields:
      loops_analyzed: Int
      loops_vectorized: Int
      scalar_ops_replaced: Int
      estimated_speedup: Float

behaviors:
  - name: analyze_loop
    given: SSA basic block with potential loop
    when: Loop pattern detected (back edge)
    then: Return LoopInfo with vectorization potential

  - name: detect_reduction
    given: Loop with accumulator pattern
    when: Pattern matches sum/product reduction
    then: Mark as vectorizable reduction

  - name: vectorize_arithmetic
    given: Sequence of identical scalar ops on array elements
    when: Operations are independent (no data dependencies)
    then: Replace with single SIMD operation

  - name: emit_vector_load
    given: Consecutive memory loads with constant stride
    when: Stride equals element size
    then: Emit vec_load instruction

  - name: emit_vector_store
    given: Consecutive memory stores with constant stride
    when: Stride equals element size
    then: Emit vec_store instruction

  - name: handle_remainder
    given: Array length not multiple of vector width
    when: Vectorized loop completes
    then: Generate scalar epilogue for remaining elements

  - name: estimate_speedup
    given: Vectorization plan
    when: All transformations identified
    then: Calculate expected speedup (typically 4-8x)

optimizations:
  - name: loop_unrolling
    description: Unroll loops to expose more SIMD opportunities
    factor: 4

  - name: alignment_check
    description: Check memory alignment for optimal SIMD loads
    alignment: 32

  - name: reduction_tree
    description: Use tree reduction for horizontal operations
    depth: log2(vector_width)

tests:
  - name: vectorize_simple_add
    input: |
      for i in 0..n:
        c[i] = a[i] + b[i]
    expected: Single vec_add instruction per iteration

  - name: vectorize_reduction
    input: |
      sum = 0
      for i in 0..n:
        sum += a[i]
    expected: vec_load + vec_reduce_add

  - name: non_vectorizable_dependency
    input: |
      for i in 1..n:
        a[i] = a[i-1] + 1
    expected: Remains scalar (loop-carried dependency)
