name: b2t_lifter
version: "1.0.0"
language: zig
module: b2t_lifter

# Binary-to-Ternary Lifter
# Lifts assembly instructions to TVC IR
# V = n × 3^k × π^m × φ^p × e^q
# φ² + 1/φ² = 3 = TRINITY

imports:
  - b2t_disasm
  - tvc_ir

types:
  LiftContext:
    fields:
      current_function: String
      current_block: String
      register_map: Map<String, Int>
      stack_offset: Int
      flags: Int

  LiftedFunction:
    fields:
      name: String
      entry_block: String
      blocks: List<tvc_ir.TVCBlock>
      parameters: List<tvc_ir.TVCType>
      return_type: tvc_ir.TVCType

  LiftedModule:
    fields:
      name: String
      functions: List<LiftedFunction>
      globals: List<tvc_ir.TVCGlobal>
      imports: List<String>

  LiftError:
    enum:
      - unsupported_instruction
      - invalid_operand
      - stack_underflow
      - type_mismatch

behaviors:
  - name: lift_module
    given: DisassemblyResult from b2t_disasm
    when: Converting all functions to TVC IR
    then: Returns LiftedModule with TVC functions

  - name: lift_function
    given: List of BasicBlocks forming a function
    when: Converting each block to TVC IR
    then: Returns LiftedFunction

  - name: lift_block
    given: BasicBlock with instructions
    when: Converting each instruction to TVC IR
    then: Returns tvc_ir.TVCBlock

  - name: lift_instruction
    given: Single Instruction
    when: Mapping to equivalent TVC IR instruction(s)
    then: Returns list of tvc_ir.TVCInstruction

  # x86_64 instruction lifting
  - name: lift_x86_mov
    given: x86_64 MOV instruction
    when: Mapping register/memory moves
    then: Returns TVC load/store instructions

  - name: lift_x86_add
    given: x86_64 ADD instruction
    when: Mapping to ternary addition
    then: Returns TVC t_add instruction

  - name: lift_x86_sub
    given: x86_64 SUB instruction
    when: Mapping to ternary subtraction
    then: Returns TVC t_sub instruction

  - name: lift_x86_cmp
    given: x86_64 CMP instruction
    when: Mapping to ternary comparison (3-way result!)
    then: Returns TVC t_cmp instruction with trit result

  - name: lift_x86_jcc
    given: x86_64 conditional jump
    when: Mapping to ternary conditional branch
    then: Returns TVC t_branch instruction

  - name: lift_x86_call
    given: x86_64 CALL instruction
    when: Mapping to TVC function call
    then: Returns TVC call instruction

  - name: lift_x86_ret
    given: x86_64 RET instruction
    when: Mapping to TVC return
    then: Returns TVC ret instruction

  # WASM instruction lifting
  - name: lift_wasm_local_get
    given: WASM local.get instruction
    when: Mapping to TVC load
    then: Returns TVC t_load instruction

  - name: lift_wasm_local_set
    given: WASM local.set instruction
    when: Mapping to TVC store
    then: Returns TVC t_store instruction

  - name: lift_wasm_i32_add
    given: WASM i32.add instruction
    when: Mapping to ternary addition
    then: Returns TVC t_add instruction

  - name: lift_wasm_call
    given: WASM call instruction
    when: Mapping to TVC call
    then: Returns TVC call instruction

  # SSA conversion
  - name: convert_to_ssa
    given: LiftedModule in non-SSA form
    when: Inserting phi nodes and renaming variables
    then: Returns LiftedModule in SSA form

  - name: insert_phi_nodes
    given: LiftedFunction with multiple definitions
    when: Computing dominance frontiers
    then: Inserts phi nodes at join points

  - name: rename_variables
    given: LiftedFunction with phi nodes
    when: Renaming variables for SSA
    then: Returns function with unique variable names

# Ternary optimization patterns
patterns:
  # Binary comparison → Ternary 3-way comparison
  - name: binary_cmp_to_ternary
    binary: |
      cmp eax, ebx
      jl less
      je equal
      jg greater
    ternary: |
      %result = t_cmp %eax, %ebx  ; result is trit: -1, 0, +1
      t_switch %result, [less, equal, greater]

  # Multiply by 3 → Ternary shift
  - name: mul3_to_shift
    binary: |
      imul eax, 3
    ternary: |
      %result = t_shift_left %eax, 1  ; ×3 in ternary = shift left

  # Boolean AND → Ternary MIN
  - name: and_to_min
    binary: |
      and eax, ebx
    ternary: |
      %result = t_min %eax, %ebx  ; ternary AND = MIN

  # Boolean OR → Ternary MAX
  - name: or_to_max
    binary: |
      or eax, ebx
    ternary: |
      %result = t_max %eax, %ebx  ; ternary OR = MAX

tests:
  - name: test_lift_push_rbp
    input:
      mnemonic: "push"
      operands: [{type: register, register_name: "rbp"}]
    expected:
      opcode: t_store
      operands: [stack_ptr, rbp_value]

  - name: test_lift_add
    input:
      mnemonic: "add"
      operands: [{type: register, register_name: "eax"}, {type: register, register_name: "ebx"}]
    expected:
      opcode: t_add

  - name: test_lift_cmp_to_ternary
    input:
      mnemonic: "cmp"
      operands: [{type: register}, {type: register}]
    expected:
      opcode: t_cmp
      result_type: trit  # -1, 0, +1
