name: b2t_prompts
version: "1.0.0"
language: zig
module: b2t_prompts

# ═══════════════════════════════════════════════════════════════════════════════
# B2T DISTORTION-AWARE PROMPTS
# Шаблоны промптов для LLM-ассистированной декомпиляции
#
# Научная основа:
# - FidelityGPT: Distortion-aware prompt templates
# - ICL4Decomp: In-context learning с примерами
# - Chain-of-Thought: Пошаговое рассуждение
#
# V = n × 3^k × π^m × φ^p × e^q
# φ² + 1/φ² = 3 = TRINITY
# ═══════════════════════════════════════════════════════════════════════════════

imports:
  - b2t_llm_assist

types:
  # ═══════════════════════════════════════════════════════════════════════════
  # PROMPT COMPONENTS
  # ═══════════════════════════════════════════════════════════════════════════

  PromptRole:
    enum:
      - system                         # Системный промпт (роль)
      - context                        # Контекст задачи
      - instruction                    # Инструкции
      - example                        # Примеры (ICL)
      - query                          # Запрос пользователя

  PromptSection:
    fields:
      role: PromptRole
      content: String
      priority: Int                    # Порядок в промпте
      required: Bool
      max_tokens: Option<Int>

  PromptConfig:
    fields:
      max_total_tokens: Int
      temperature: Float
      top_p: Float
      presence_penalty: Float
      frequency_penalty: Float

  # ═══════════════════════════════════════════════════════════════════════════
  # DISTORTION-SPECIFIC TEMPLATES
  # ═══════════════════════════════════════════════════════════════════════════

  DistortionTemplate:
    fields:
      distortion_type: String          # Тип искажения
      detection_prompt: String         # Промпт для детекции
      correction_prompt: String        # Промпт для исправления
      validation_prompt: String        # Промпт для валидации
      examples: List<DistortionExample>

  DistortionExample:
    fields:
      distorted_code: String
      corrected_code: String
      explanation: String
      distortion_markers: List<String> # Маркеры искажения

  # ═══════════════════════════════════════════════════════════════════════════
  # CHAIN-OF-THOUGHT
  # ═══════════════════════════════════════════════════════════════════════════

  ReasoningStep:
    fields:
      step_number: Int
      description: String
      expected_output: String

  ChainOfThought:
    fields:
      task: String
      steps: List<ReasoningStep>
      final_instruction: String

behaviors:
  # ═══════════════════════════════════════════════════════════════════════════
  # PROMPT CONSTRUCTION
  # ═══════════════════════════════════════════════════════════════════════════

  - name: build_system_prompt
    given: Роль агента и ограничения
    when: Создание системного промпта
    then: Возвращает PromptSection с role=system

  - name: build_context_section
    given: SemanticContext из b2t_llm_assist
    when: Форматирование контекста
    then: Возвращает PromptSection с role=context

  - name: build_icl_examples
    given: List<SimilarCode> и max_examples
    when: Форматирование примеров для ICL
    then: Возвращает PromptSection с role=example

  - name: build_query
    given: Декомпилированный код и задача
    when: Формирование запроса
    then: Возвращает PromptSection с role=query

  - name: assemble_prompt
    given: List<PromptSection> и PromptConfig
    when: Сборка финального промпта с учётом лимитов
    then: Возвращает String промпт

  # ═══════════════════════════════════════════════════════════════════════════
  # DISTORTION-AWARE PROMPTS
  # ═══════════════════════════════════════════════════════════════════════════

  - name: get_distortion_template
    given: DistortionType
    when: Получение шаблона для конкретного искажения
    then: Возвращает DistortionTemplate

  - name: format_detection_prompt
    given: Код и DistortionTemplate
    when: Создание промпта для детекции искажений
    then: Возвращает String промпт

  - name: format_correction_prompt
    given: Код, искажения и DistortionTemplate
    when: Создание промпта для исправления
    then: Возвращает String промпт

  - name: format_validation_prompt
    given: Оригинал, исправление и DistortionTemplate
    when: Создание промпта для валидации
    then: Возвращает String промпт

  # ═══════════════════════════════════════════════════════════════════════════
  # CHAIN-OF-THOUGHT
  # ═══════════════════════════════════════════════════════════════════════════

  - name: create_cot_prompt
    given: Задача и ChainOfThought
    when: Создание промпта с пошаговым рассуждением
    then: Возвращает String промпт

  - name: parse_cot_response
    given: Ответ LLM с рассуждениями
    when: Извлечение шагов и финального ответа
    then: Возвращает структурированный результат

# ═══════════════════════════════════════════════════════════════════════════════
# SYSTEM PROMPTS
# ═══════════════════════════════════════════════════════════════════════════════

system_prompts:
  maxwell_decompiler: |
    Ты Maxwell — автономный агент-декомпилятор, работающий на принципах троичной логики.
    
    ТВОЯ РОЛЬ:
    - Анализировать декомпилированный код и находить семантические искажения
    - Восстанавливать осмысленные имена переменных и функций
    - Исправлять структуру потока управления
    - Выводить корректные типы данных
    
    ПРИНЦИПЫ ТРОИЧНОЙ ЛОГИКИ:
    - Для каждого решения рассматривай три исхода: отрицательный, нейтральный, положительный
    - Используй формулу: φ² + 1/φ² = 3 = TRINITY
    - Неопределённость — это не ошибка, а третье состояние
    
    ОГРАНИЧЕНИЯ:
    - Генерируй ТОЛЬКО код, без объяснений (если не запрошено)
    - Сохраняй семантику оригинала
    - Не добавляй функциональность, которой не было
    
    ФОРМАТ ОТВЕТА:
    ```c
    // исправленный код
    ```

  distortion_detector: |
    Ты эксперт по анализу качества декомпиляции.
    
    ТВОЯ ЗАДАЧА:
    Найти семантические искажения в декомпилированном коде.
    
    ТИПЫ ИСКАЖЕНИЙ:
    1. variable_naming — бессмысленные имена (v1, v2, sub_1234)
    2. type_inference — неверные типы (int вместо pointer)
    3. control_flow — искажённые циклы и условия
    4. loop_structure — потеря структуры for/while
    5. function_boundary — неверные границы функций
    6. calling_convention — ошибки ABI
    7. memory_access — неверные указатели
    8. constant_propagation — потеря констант
    9. dead_code — ложный мёртвый код
    10. inlining_artifact — артефакты инлайнинга
    
    ФОРМАТ ОТВЕТА:
    ```json
    {
      "distortions": [
        {
          "type": "variable_naming",
          "line": 5,
          "severity": 0.8,
          "description": "v1 should be 'buffer_size'"
        }
      ]
    }
    ```

  semantic_recoverer: |
    Ты эксперт по восстановлению семантики из бинарного кода.
    
    КОНТЕКСТ:
    Тебе дан декомпилированный код с искажениями и дополнительный контекст:
    - Граф потока данных (data flow)
    - Граф вызовов (call graph)
    - Строковые литералы
    - Импортируемые символы
    
    ТВОЯ ЗАДАЧА:
    Восстановить осмысленный код, используя весь доступный контекст.
    
    СТРАТЕГИЯ:
    1. Проанализируй строковые литералы — они часто указывают на назначение
    2. Изучи граф вызовов — имена библиотечных функций информативны
    3. Проследи поток данных — откуда приходят и куда уходят значения
    4. Примени паттерны — типичные конструкции (malloc/free, open/close)
    
    φ² + 1/φ² = 3 = TRINITY

# ═══════════════════════════════════════════════════════════════════════════════
# DISTORTION TEMPLATES
# ═══════════════════════════════════════════════════════════════════════════════

distortion_templates:
  variable_naming:
    detection: |
      Найди переменные с бессмысленными именами в этом коде:
      ```
      {code}
      ```
      
      Признаки бессмысленных имён:
      - Однобуквенные (v1, v2, a, b) кроме счётчиков циклов
      - Автогенерированные (var_1234, sub_5678)
      - Не отражающие назначение
      
      Для каждой найденной переменной укажи:
      - Текущее имя
      - Предполагаемое назначение
      - Предложенное имя
      
    correction: |
      Исправь имена переменных в этом коде:
      ```
      {code}
      ```
      
      КОНТЕКСТ:
      - Строки в коде: {string_refs}
      - Вызываемые функции: {callees}
      - Типы данных: {types}
      
      ОБНАРУЖЕННЫЕ ПРОБЛЕМЫ:
      {distortions}
      
      ПРИМЕРЫ ИСПРАВЛЕНИЙ:
      {examples}
      
      Выведи ТОЛЬКО исправленный код.
      
    validation: |
      Проверь, что исправление имён переменных корректно:
      
      ОРИГИНАЛ:
      ```
      {original}
      ```
      
      ИСПРАВЛЕНО:
      ```
      {corrected}
      ```
      
      Проверь:
      1. Семантика сохранена?
      2. Новые имена осмысленны?
      3. Нет конфликтов имён?
      
      Ответь: VALID или INVALID с объяснением.

  type_inference:
    detection: |
      Найди ошибки вывода типов в этом коде:
      ```
      {code}
      ```
      
      Признаки ошибок:
      - int используется для указателей
      - Неверная ширина (int32 vs int64)
      - Отсутствие структур (плоские массивы вместо struct)
      - Неверные сигнатуры функций
      
    correction: |
      Исправь типы в этом коде:
      ```
      {code}
      ```
      
      КОНТЕКСТ:
      - Сигнатуры вызываемых функций: {signatures}
      - Размеры данных: {sizes}
      - Паттерны доступа к памяти: {memory_patterns}
      
      ОБНАРУЖЕННЫЕ ПРОБЛЕМЫ:
      {distortions}
      
      ПРИМЕРЫ:
      {examples}
      
      Выведи ТОЛЬКО исправленный код с правильными типами.
      
    validation: |
      Проверь корректность исправления типов:
      
      ОРИГИНАЛ:
      ```
      {original}
      ```
      
      ИСПРАВЛЕНО:
      ```
      {corrected}
      ```
      
      Проверь:
      1. Типы совместимы с операциями?
      2. Размеры данных корректны?
      3. Указатели правильно типизированы?

  control_flow:
    detection: |
      Найди искажения потока управления:
      ```
      {code}
      ```
      
      TVC IR (эталон):
      ```
      {tvc_ir}
      ```
      
      Признаки искажений:
      - goto вместо структурных конструкций
      - Вложенные if вместо switch
      - Развёрнутые циклы
      - Дублированный код
      
    correction: |
      Восстанови структуру потока управления:
      ```
      {code}
      ```
      
      TVC IR показывает правильную структуру:
      ```
      {tvc_ir}
      ```
      
      ПРИМЕРЫ ВОССТАНОВЛЕНИЯ:
      {examples}
      
      Преобразуй goto в структурные конструкции.
      Выведи ТОЛЬКО исправленный код.
      
    validation: |
      Проверь эквивалентность потока управления:
      
      ОРИГИНАЛ:
      ```
      {original}
      ```
      
      ИСПРАВЛЕНО:
      ```
      {corrected}
      ```
      
      TVC IR:
      ```
      {tvc_ir}
      ```
      
      Семантика должна быть идентичной!

# ═══════════════════════════════════════════════════════════════════════════════
# CHAIN-OF-THOUGHT TEMPLATES
# ═══════════════════════════════════════════════════════════════════════════════

chain_of_thought:
  full_decompilation:
    task: "Полное восстановление семантики декомпилированного кода"
    steps:
      - step: 1
        description: "Анализ строковых литералов"
        instruction: |
          Найди все строковые литералы в коде и контексте.
          Что они говорят о назначении функции?
          
      - step: 2
        description: "Анализ графа вызовов"
        instruction: |
          Какие функции вызываются?
          Какие библиотечные функции используются?
          Что это говорит о функциональности?
          
      - step: 3
        description: "Анализ потока данных"
        instruction: |
          Откуда приходят входные данные?
          Куда уходят выходные данные?
          Какие преобразования происходят?
          
      - step: 4
        description: "Детекция искажений"
        instruction: |
          Какие искажения присутствуют?
          Какова их severity?
          В каком порядке исправлять?
          
      - step: 5
        description: "Применение исправлений"
        instruction: |
          Исправь искажения по приоритету.
          Проверь, что семантика сохранена.
          
      - step: 6
        description: "Финальная валидация"
        instruction: |
          Код компилируется?
          Семантика эквивалентна оригиналу?
          Имена осмысленны?
          
    final_instruction: |
      Выведи финальный исправленный код в формате:
      ```c
      // Восстановленный код
      ```

tests:
  - name: test_system_prompt_format
    input:
      prompt_type: "maxwell_decompiler"
    expected:
      contains_trinity: true
      contains_role: true

  - name: test_distortion_template
    input:
      distortion_type: "variable_naming"
      code: "int v1 = v2 + v3;"
    expected:
      detection_prompt_valid: true
      correction_prompt_valid: true

  - name: test_cot_assembly
    input:
      task: "full_decompilation"
      steps_count: 6
    expected:
      prompt_has_all_steps: true
